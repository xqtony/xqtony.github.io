[{"title":"区分几个reverse方法","date":"2023-05-25T23:24:08.374Z","path":"2023/05/26/reverses/","text":"下列的几个reverse你能分清楚吗？ 1234Comparator.reversed();Comparator.reverseOrder();Collections.reverse();Collections.reverseOrder(); 来看看源码： Comparator.reversed(): 12default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this); 返回一个比较器，强制该比较器的相反顺序。 Comparator.reverseOrder: 123public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() &#123; return Collections.reverseOrder();&#125; 返回一个与 自然排序相反的比较器。 Collections.reverse(): 1234567891011121314151617181920public static void reverse(List&lt;?&gt; list) &#123; int size = list.size(); if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--) swap(list, i, j); &#125; else &#123; ListIterator fwd = list.listIterator(); ListIterator rev = list.listIterator(size); for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) &#123; Object tmp = fwd.next(); fwd.set(rev.previous()); rev.set(tmp); &#125; &#125;&#125;private static void swap(List&lt;?&gt; list, int i, int j) &#123; final List l = list; l.set(i, l.set(j, l.get(i)));&#125; 此方法反转指定列表中元素的顺序。 Collections.reverseOrder(): 12345678910111213public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) &#123; if (cmp == null) &#123; return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER; &#125; else if (cmp == ReverseComparator.REVERSE_ORDER) &#123; return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE; &#125; else if (cmp == Comparators.NaturalOrderComparator.INSTANCE) &#123; return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER; &#125; else if (cmp instanceof ReverseComparator2) &#123; return ((ReverseComparator2&lt;T&gt;) cmp).cmp; &#125; else &#123; return new ReverseComparator2&lt;&gt;(cmp); &#125; &#125; 此方法返回一个比较器，它强制指定比较器的反向排序。当不指定比较器的时候，返回ReverseComparator.REVERSE_ORDER。那顺便看下ReverseComparator的实现： 12345678910111213141516171819private static class ReverseComparator implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable &#123; @java.io.Serial private static final long serialVersionUID = 7207038068494060240L; static final ReverseComparator REVERSE_ORDER = new ReverseComparator(); public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) &#123; return c2.compareTo(c1); &#125; @java.io.Serial private Object readResolve() &#123; return Collections.reverseOrder(); &#125; @Override public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123; return Comparator.naturalOrder(); &#125; 可见ReverseComparator.REVERSE_ORDER排序的顺序与自然排序刚好相反。 总结： Comparator.reversed(): 无参数。底层调用Collections.reverseOrder(this)。返回一个与调用者比较器相反顺序的新的比较器。 Comparator.reverseOrder(): 无参数。底层调用Collections.reverseOrder()。返回一个与自然排序相反的比较器。 Collections.reverse(): 接受一个List类型参数，反转该List。无返回值。 Collections.reverseOrder(): 无参调用时，返回一个与自然排序相反的比较器；有参调用时，返回与参数相反的比较器。 参考： Java Comparator使用指南 —- 看这一篇就够了Java 8 新特性】Java Comparator.reverseOrder | 倒序排序-静态方法深入学习java源码之Comparator.reverseOrder()与Comparator.compare ()Java.util.Collections 类","tags":[{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"Collections","slug":"Collections","permalink":"https://xqtony.github.io/tags/Collections/"},{"name":"Comparator","slug":"Comparator","permalink":"https://xqtony.github.io/tags/Comparator/"},{"name":"reverse","slug":"reverse","permalink":"https://xqtony.github.io/tags/reverse/"}]},{"title":"Lambda中比较器Comparator的使用","date":"2023-05-25T22:15:31.551Z","path":"2023/05/26/lambda in Comparator/","text":"如果你赶时间： 12list.sort((Developer o1, Developer o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); // 显式类型listDevs.sort((o1, o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); // 隐式类型，效果一致 一、概念先来看下典型的比较器示例： 123456Comparator&lt;Developer&gt; byName = new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getName().compareTo(o2.getName()); // name是String类型 &#125;&#125; Java8中引入了Lambda表达式，比较器可以改成下面这样： 1Comparator&lt;Developer&gt; byName = (Developer o1, Developer o2) -&gt; o1.getName().compareTo(o2.getName()); 对于数组，Arrays.sort()提供了传入比较器的重载方法，对于列表，Collections.sort()也提供了传入比较器的重载方法。 二、使用实例2.1 通过new 新建比较器假如我们要通过Developer 对象的年龄进行排序，通常情况下我们使用Collections.sort，new个匿名Comparator 类，类似下面这种： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.math.BigDecimal;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class TestSorting &#123; public static void main(String[] args) &#123; List&lt;Developer&gt; listDevs = getDevelopers(); System.out.println(&quot;Before Sort&quot;); for (Developer developer : listDevs) &#123; System.out.println(developer); &#125; //sort by age Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // return o1.getAge() - o2.getAge(); return Integer.compare(o1.getAge(), o2.getAge()); &#125; &#125;); System.out.println(&quot;After Sort&quot;); for (Developer developer : listDevs) &#123; System.out.println(developer); &#125; &#125; private static List&lt;Developer&gt; getDevelopers() &#123; List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;(); result.add(new Developer(&quot;ricky&quot;, new BigDecimal(&quot;70000&quot;), 33)); result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;), 20)); result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;), 10)); result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;), 55)); return result; &#125;&#125; 输出结果： 1234567891011Before SortDeveloper [name=ricky, salary=70000, age=33]Developer [name=alvin, salary=80000, age=20]Developer [name=jason, salary=100000, age=10]Developer [name=iris, salary=170000, age=55]After SortDeveloper [name=jason, salary=100000, age=10]Developer [name=alvin, salary=80000, age=20]Developer [name=ricky, salary=70000, age=33]Developer [name=iris, salary=170000, age=55] 当比较规则发生变化时，你需要再次new个匿名Comparator 类： 123456789101112131415161718192021222324252627//sort by ageCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // Tony updated: 尽管几乎不可能溢出，但存在这种可能性 // return o1.getAge() - o2.getAge(); // 参考这篇博客：https://xqtony.github.io/2023/05/26/compareTo/ // 应该使用下面的实现方法： return Integer.compare(o1.getAget(), o2.getAge()); &#125;&#125;);//sort by nameCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getName().compareTo(o2.getName()); &#125;&#125;);//sort by salaryCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getSalary().compareTo(o2.getSalary()); &#125;&#125;); 这样也可以，不过你会不会觉得这样有点怪，因为其实不同的只有一行代码而已，但是却需要重复写很多代码？ 2.2 通过Lambda表达式新建比较器在java8中，List接口直接提供了排序方法， 所以你不需要使用Collections.sort： 123456789101112//List.sort() since Java 8listDevs.sort(new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // Tony：原文中存在两个问题： // 1. 溢出风险 // 2. 顺序写反了 // return o2.getAge() - o1.getAge(); // Tony: return Integer.compare(o1.getAget(), o2.getAge()); &#125;&#125;); Lambda改写： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;public class TestSorting &#123; public static void main(String[] args) &#123; List&lt;Developer&gt; listDevs = getDevelopers(); System.out.println(&quot;Before Sort&quot;); for (Developer developer : listDevs) &#123; System.out.println(developer); &#125; System.out.println(&quot;After Sort&quot;); // Tony： 原文使用了下面的实现 // listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge()); listDevs.sort((Developer o1, Developer o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); //java 8 lambda feature listDevs.forEach((developer)-&gt;System.out.println(developer)); // Tony注： // listDevs.forEach(System.out::println); &#125; private static List&lt;Developer&gt; getDevelopers() &#123; List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;(); result.add(new Developer(&quot;ricky&quot;, new BigDecimal(&quot;70000&quot;), 33)); result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;), 20)); result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;), 10)); result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;), 55)); return result; &#125;&#125; 输出： 1234567891011Before SortDeveloper [name=ricky, salary=70000, age=33]Developer [name=alvin, salary=80000, age=20]Developer [name=jason, salary=100000, age=10]Developer [name=iris, salary=170000, age=55]After SortDeveloper [name=jason, salary=100000, age=10]Developer [name=alvin, salary=80000, age=20]Developer [name=ricky, salary=70000, age=33]Developer [name=iris, salary=170000, age=55] 2.3 更多的例子根据年龄： 123456789101112131415161718 //sort by ageCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // return o1.getAge() - o2.getAge(); return Integer.compare(o1.getAget(), o2.getAge()); &#125;&#125;);//lambda// Tony 注：同样的问题// listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge());listDevs.sort((Developer o1, Developer o2) -&gt; Integer.compare(o1.getAge(), o2.getAge()));//lambda, valid, parameter type is optional// Tony 注：同样的问题// listDevs.sort((o1, o2)-&gt;o1.getAge()-o2.getAge());listDevs.sort((o1, o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); 根据名字： 12345678910111213//sort by nameCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getName().compareTo(o2.getName()); &#125;&#125;);//lambdalistDevs.sort((Developer o1, Developer o2)-&gt;o1.getName().compareTo(o2.getName()));//lambdalistDevs.sort((o1, o2)-&gt;o1.getName().compareTo(o2.getName())); 根据薪水： 1234567891011121314//sort by salaryCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getSalary().compareTo(o2.getSalary()); &#125;&#125;);//lambda// Tony注：使用compareTo()同样可以，本质上底层还是在调用compare()方法listDevs.sort((Developer o1, Developer o2)-&gt;o1.getSalary().compareTo(o2.getSalary()));//lambdalistDevs.sort((o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary())) 从小到大排序： 12Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary());listDevs.sort(salaryComparator); 从大到小倒序： 123456Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary());listDevs.sort(salaryComparator.reversed());// Tony 注：掘金版本给出了下面的实现：// Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o2.getSalary().compareTo(o1.getSalary());// 但是实际上根据Comparator接口中compare函数的定义，当o1的值小于o2，应该返回负值。因此上面这行的实现违反设计原则的，并不推荐。 本文虽然大部分是转载，但关于Integer类型的数值比较防止溢出问题，以及对compare()方法的设计均有重要注解，因此归类为二创。 参考：java8-Lambda中比较器Comparator的使用 - CSDNjava8-Lambda中比较器Comparator的使用 - 掘金Java8 Lambda表达式（二）System.out::println与Lambda表达式","tags":[{"name":"compare","slug":"compare","permalink":"https://xqtony.github.io/tags/compare/"},{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"二创","slug":"二创","permalink":"https://xqtony.github.io/tags/%E4%BA%8C%E5%88%9B/"},{"name":"Comparator","slug":"Comparator","permalink":"https://xqtony.github.io/tags/Comparator/"},{"name":"Lambda","slug":"Lambda","permalink":"https://xqtony.github.io/tags/Lambda/"}]},{"title":"比较Collections.sort()与Arrays.sort()","date":"2023-05-25T22:04:40.531Z","path":"2023/05/26/two sort/","text":"Collections.sort() 与 Arrays.sort() 的异同？Collections.sort() 和 Arrays.sort() 都是 Java 中用于排序的方法，它们的异同如下： 参数类型不同：Collections.sort() 方法接受 List 类型的参数，而 Arrays.sort() 方法接受数组类型的参数。 底层实现不同：Collections.sort() 方法使用的是归并排序（Merge Sort）算法，而 Arrays.sort() 方法使用的是快速排序（Quick Sort）算法。 排序稳定性不同：Collections.sort() 方法是稳定排序，即对于相等的元素，排序前后它们的相对位置不会发生改变。而 Arrays.sort() 方法是不稳定排序，即对于相等的元素，排序前后它们的相对位置可能会发生改变。 性能表现不同：Arrays.sort() 方法在大多数情况下比 Collections.sort() 方法性能更好，因为它对原始数据进行排序，不需要进行额外的包装和拆包操作。 综上所述，如果需要对 List 进行排序，应该使用 Collections.sort() 方法；而如果需要对数组进行排序，应该使用 Arrays.sort() 方法。 但需要注意的是，Arrays.sort() 方法和Collections.sort() 方法在排序时都可能会改变原始对象内元素的顺序，所以在使用前需要备份。 另外注意，使用Collections.sort()时，被排序列表中的元素必须实现Comparable接口中的compareTo方法。 参考：Java中Collections.sort()的使用!","tags":[{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"Collections","slug":"Collections","permalink":"https://xqtony.github.io/tags/Collections/"},{"name":"Arrays","slug":"Arrays","permalink":"https://xqtony.github.io/tags/Arrays/"},{"name":"sort","slug":"sort","permalink":"https://xqtony.github.io/tags/sort/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"}]},{"title":"比较Comparator与Comparable接口","date":"2023-05-25T21:54:15.297Z","path":"2023/05/26/comparable vs comparator/","text":"简单比较下Comparator与Comparable接口Comparator 和 Comparable 都是 Java 中用于比较对象大小的接口，但它们有以下区别： 接口位置不同：Comparable 接口位于 java.lang 包中，而 Comparator 接口位于 java.util 包中。 实现方式不同：实现 Comparable 接口的类需要重写 compareTo() 方法，而实现 Comparator 接口的类需要重写 compare() 方法。 使用场景不同：实现 Comparable 接口的类通常用于已经有一定顺序的情况下，例如对整数或字符串进行排序。而实现 Comparator 接口的类通常用于需要动态指定排序方式的情况下，例如对自定义对象进行排序。 排序方式不同：Comparable 接口是内部比较器，它定义了对象的自然顺序，即对象本身就有了固定的比较规则。而 Comparator 接口是外部比较器，它允许用户根据需要指定不同的比较规则。 综上所述，Comparable 接口适用于已经有一定顺序的情况下，而 Comparator 接口适用于需要动态指定排序方式的情况下。 以下是 Comparable 和 Comparator 的用法实例：Comparable 实例： 12345678910111213141516171819202122public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public int compareTo(Person other) &#123; return Integer.compare(this.age, other.age); &#125;&#125; 在这个例子中，我们定义了一个 Person 类，并实现了 Comparable 接口。在 compareTo() 方法中，我们使用 Integer.compare() 方法比较了两个 Person 对象的年龄大小关系，从而定义了 Person 对象的自然顺序。这样，我们就可以在使用 Collections.sort() 或 Arrays.sort() 方法时，直接对 &#96;Person 对象进行排序。 Comparator 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;public class PersonCompartor implements Comparator&lt;Person&gt; &#123; @Override public int compare(Person p1, Person p2) &#123; return Integer.compare(p1.getAge(), p2.getAge()); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person[] people=new Person[]&#123;new Person(&quot;Tony&quot;, 20),new Person(&quot;Xiangqi&quot;, 10)&#125;; System.out.println(&quot;排序前&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; Arrays.sort(people,new PersonCompartor()); System.out.println(&quot;\\n排序后&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; &#125;&#125; 在这个例子中，我们同样定义了一个 Person 类，但没有实现 Comparable 接口。然后，我们创建了一个 PersonComparator 类，实现了 Comparator 接口，并重写了 compare() 方法。在 compare() 方法中，我们比较了两个 Person 对象的年龄大小关系，从而定义了 Person 对象的比较规则。这样，我们就可以在使用 Collections.sort() 或 Arrays.sort() 方法时，使用 PersonComparator 对象进行排序。 参考文献： Java中Comparable和Comparator区别小结","tags":[{"name":"compareTo","slug":"compareTo","permalink":"https://xqtony.github.io/tags/compareTo/"},{"name":"compare","slug":"compare","permalink":"https://xqtony.github.io/tags/compare/"},{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"},{"name":"Comparator","slug":"Comparator","permalink":"https://xqtony.github.io/tags/Comparator/"},{"name":"Comparable","slug":"Comparable","permalink":"https://xqtony.github.io/tags/Comparable/"}]},{"title":"浅谈compareTo()方法","date":"2023-05-25T20:19:45.560Z","path":"2023/05/26/compareTo/","text":"下面这段代码使用了 compareTo() 方法，有问题吗？123456789class Employee implements Comparable &#123; private int id; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return this.id - emp.id; &#125;&#125; 使用减法看起来合乎逻辑，但实际上隐藏了溢出的问题。 当我们需要按照一定的规则进行排序的时候，通常要实现 Comparable 接口，并实现 compareTo 方法，规则如下： 1）如果当前对象小于另外一个对象，则 compareTo 方法必须返回负数；如果当前对象大于另外一个对象，则必须返回正数；如果两个对象相等，则返回零。 2）通常来说，compareTo 方法必须和 equals 方法一致，如果两个对象通过 equals 方法判断的结果为 true，那么 compareTo 必须返回零。 不过，JDK 中有一个反例，就是 BigDecimal。 12345BigDecimal bd1 = new BigDecimal(&quot;2.0&quot;);BigDecimal bd2 = new BigDecimal(&quot;2.00&quot;);System.out.println(&quot;equals: &quot; + bd1.equals(bd2));System.out.println(&quot;compareTo: &quot; + bd1.compareTo(bd2)); 输出结果如下所示： 12equals: falsecompareTo: 0 这是因为 JDK 认为 2.0 和 2.00 的精度不一样，所以不能 equals，但值确实是相等的。 3）不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 Integer.compareTo() 来进行比较。如果你想通过减法操作来提高性能，必须得确保两个操作数是正整数，或者确保两者相差的值小于 Integer.MAX_VALUE。 12345678910111213141516171819202122232425262728293031public class CompareDemo &#123; public static void main(String[] args) &#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); list.add(new Employee(1)); list.add(new Employee(Integer.MIN_VALUE)); list.add(new Employee(Integer.MAX_VALUE)); Collections.sort(list); System.out.println(list); &#125;&#125;class Employee implements Comparable &#123; private int id; public Employee(int id) &#123; this.id = id; &#125; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return this.id - emp.id; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; 程序的输出结果如下所示： 1[Employee&#123;id=1&#125;, Employee&#123;id=2147483647&#125;, Employee&#123;id=-2147483648&#125;] 排序就乱了。因为 Integer.MIN_VALUE - 1 变成了正数 2147483647。 回到最开始的问题，正确的写法应该是 123456789class Employee implements Comparable &#123; private int id; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return Integer.valueOf(this.id).compareTo(emp.id); &#125;&#125; 实际上，Integer.compareTo()底层是通过调用Integer.compare()方法实现的： 12345678public int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125;public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x == y) ? 0 : 1); &#125; 所以上面的问题可以重写为 123456789class Employee implements Comparable &#123; private int id; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return Integer.compare(this.id, emp.id); &#125;&#125; 值得注意的是，String类型只有compareTo方法，而没有compare方法。给出源代码进行参考： 12345678910111213141516171819public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; 可见String类型不需要compare方法。 基于这10道基础Java面试题，虐哭了多少人改写。 参考： List集合排序Collections.sort()方法的一个容易忽略的小问题","tags":[{"name":"compareTo","slug":"compareTo","permalink":"https://xqtony.github.io/tags/compareTo/"},{"name":"compare","slug":"compare","permalink":"https://xqtony.github.io/tags/compare/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://xqtony.github.io/tags/BigDecimal/"},{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"二创","slug":"二创","permalink":"https://xqtony.github.io/tags/%E4%BA%8C%E5%88%9B/"}]},{"title":"","date":"2023-05-23T04:49:36.894Z","path":"2023/05/23/todo/","text":"待办事项罗列出即将在github上线的demo项目，来研究新技术 Java Java虚拟机原理 Java高级特性和类库 Java网络与服务器编程 Java多线程编程 JVM调优 NIO、RPC框架 Golang Golang语言机制 开发工具的使用，定位和调试问题 分布式 理解什么是分布式架构，精通主流框架原理 Spring Cloud Dubbo Zookeeper 中间件 MySQL Redis HBase MongoDB Kafka ElasticSearch 前端技术 JS JQuery ReactJs Vue 网络编程 HTTP协议 缓存 序列化 RPC框架 容器 Docker K8s （含二次开发） Linux 编写脚本bash shell 熟悉环境 DevOps DevOps概念 CI&#x2F;CD pipelines 理论基础 计算机网络 数据结构 操作系统 算法 设计模式 软实力 技术钻研能力 分析问题解决问题 独立承担任务 系统进度把控 独立负责跨足项目 结果导向 代码风格及文档 良好的编码习惯 技术文档编写能力 英语书面交流 没来得及整理的内容https://www.cnblogs.com/kuanglongblogs/p/11230250.html","tags":[]},{"title":"MySQL数据库 - 基础篇","date":"2023-05-22T16:28:19.611Z","path":"2023/05/23/MySQL_DB_basic/","text":"概述是一种 关系型数据库：建立在关系模型上，由多张互相连接的二维表组成的数据库。关系数据库 特点：1. 使用表存储数据，格式统一，便于维护2. 使用SQL语言操作，标准统一，使用方便MySQL的数据模型从客户端到DBMS，再到数据库，最后到达数据库中的表 MySQL启动的命令 12net start mysql80 # 这里的mysql80是注册在Windows中的服务名称net stop mysql80 MySQL客户端连接MySQL自带的客户端命令行CMD执行命令： 1mysql -h 127.0.0.1 -P 3306 -u root -p SQLSQL通用语法1. SQL语句单行，多行均可，默认分号结尾2. 使用空格&#x2F;缩进以增加可读性3. 不区分大小写，推荐关键字使用大写4. 注释：单行注释：– 通用，# MySQL独有多行注释：&#x2F;**&#x2F;SQL分类：DDL: Data Definition Language 数据定义语言，用来定义数据库对象 （数据库，表，字段）DML: Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改DQL: Data Query Language 数据查询语言，用来查询数据库中表的记录DCL: Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限DDL-数据库操作:查询查询所有数据库 1SHOW DATABASES; 查询当前数据库 1SELECT DATABASE(); 创建 1CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则] 案例： 12create database if not exists test; -- 如果不存在，创建test数据库create database itheima default charset utf8mb4; -- 创建utf8mb4字符集的itheima 数据库 删除 1DROP DATABASE [IF EXISTS] 数据库名 使用数据库 1USE 数据库名 查询当前数据库全部表 1SHOW TABLES; 查询表结构 1DESC 表名 或者 DESCRIBE 表名 查询指定表的建表语句 1SHOW CREATE TABLE 表名 DDL-表操作-创建 123456CREATE TABLE 表名( 字段1 字段1类型[COMMENT 字段1注释], 字段2 字段2类型[COMMENT 字段2注释], ...... 字段n 字段n类型[COMMENT 字段n注释])[COMMENT 注释]; 第二章讲解InnoDB底层原理 DDL-表操作-数据类型主要分三类：数值类型，字符串类型，日期时间类型数值类型 实例： 12age TINYINT UNSIGNED # 0~255的整数score DOUBLE(4, 1) #100.0最长是4，填4，80.5，70.5，最多一位小数，填1。 字符串类型 定长&#x2F;变长字符串的区别 12char(10) # 长度固定为10，没用的部分用空格补位 --&gt; 性能好？varchar(10) # 长度最长不超过10，小于10时体现实际长度 --&gt; 性能较差 实例：用户名 username 用那个更好呢？答案：varchar(50)更好。因为用户的用户名不是定长的，使用varchar可以节约空间性别 gender 用哪个？答案：char(1)日期类型 实例： 1birthday date # 生日用date类型更合适 案例：根据需求创建表（设计合理的数据类型、长度） 答案： 123456789create table emp ( id int comment &#x27;编号&#x27;, workno varchar(10) comment &#x27;工号&#x27;, name varchar(10) comment &#x27;姓名&#x27;, gender char(1) comment &#x27;性别&#x27;, age tinyint unsigned comment &#x27;年龄&#x27;, idcard char(18) comment &#x27;身份证号&#x27;, entrydate date comment &#x27;入职时间&#x27;) comment &#x27;员工表&#x27;; DDL-表操作-修改添加字段 1ALTER TABLE 表名 ADD 字段名 类型（长度） [COMMENT 注释] [约束]; 案例：为emp表添加一个字段“昵称”为nickname，类型为varchar(20)答案： 1ALTER TABLE emp add nickname varchar(20) comment &#x27;昵称&#x27;; 修改数据类型 1ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型 1ALTER TABLE 表名 CHANGE 旧字段名 新字段名称 类型（长度） [COMMENT 注释] [约束]; 案例：将emp表的nickname 修改为username，类型为varchar(30)答案： 1ALTER TABLE emp change nickname username varchar(30) comment &#x27;用户名&#x27;; 删除字段 1ALTER TABLE 表名 DROP 字段名; 案例：删除emp中的username列答案： 1ALTER TABLE emp drop username; 修改表名 1ALTER TABLE 表名 RENAME TO 新表名; 案例：将emp表表名修改为employee 1ALTER TABLE emp RENAME TO employee; 删除表 1DROP TABLE [IF EXISTS] 表名; 删除指定表，并重新创建该表 1TRUNCATE TABLE 表名; MySQL图形化界面： MySQL WorkbenchDML-介绍DML的全称是Data Manipulation Lanagage (数据操作语言），用来对数据表中的数据记录进行增删改操作。添加数据 (INSERT)修改数据 (UPDATE)删除数据 (DELETE)DML-添加数据1. 给指定字段添加数据 1INSERT INTO 表名 (字段1， 字段2, ...) VALUES (值1， 值2, ...); 2. 给全部字段添加数据 1INSERT INTO 表名 VALUSE (值1， 值2, ...); 3. 批量添加数据 12INSERT INTO 表名 (字段名1，字段名2，...) VALUSE (值1，值2，...), VALUSE (值1，值2，...);INSERT INTO 表名 VALUSE (值1，值2，...), VALUSE (值1，值2，...); 注意： DML-修改数据UPDATE 表名 SET 字段名1&#x3D;值1, 字段名2&#x3D;值2, … [WHERE 条件];注意：如果修改的条件没有，则会修改整张表的数据。案例： 12345678-- id = 1 的名字修改为it 黑马update employee set name = &#x27;kelly&#x27; where id = 1;-- id = 1 的名字修改为Kelly, gender 修改为女update employee set name = &#x27;kelly&#x27;, gender = &#x27;W&#x27; where id = 1;-- 将所有员工的入职时间设定为2008-01-01update employee set entrydate = &#x27;2008-01-01&#x27;; DML-删除数据DELETE FROM 表名 [WHERE 条件];注意：DELETE语句的条件可有可无，没有的情况下会删除整张表的数据。DELETE语句不能删除某一个字段的值（可以使用UPDATE）。案例： 12345-- 删除gender为W的员工DELETE FROM employee WHERE gender = &#x27;W&#x27;;-- 删除所有员工DELETE FROM employee; DQL-介绍DQL是Data Query Language 的缩写，用来查询数据库中表的记录。查询关键字：SELECTDQL-语法 1234SELECT 字段列表 FROM 表名列表WHERE 条件列表 GROUP BY 分组字段列表HAVING 分组后条件列表 ORDER BY 排序字段列表LIMIT 分页参数 基本查询条件查询 WHERE聚合函数 count(), max(), min(), avg(), sum()分组查询 GROUP BY排序查询 ORDER BY分页查询 LIMITDQL-基本查询1. 查询返回多个字段 12SELECT 字段1，字段2，字段3... FROM 表名;SELECT * FROM 表名; 2. 设置别名 1SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名; 其中AS可以省略3. 去除重复记录 1SELECT DISTINCT 字段列表 FROM 表名; 案例：数据准备： 12345678910111213141516171819202122232425262728293031-- 数据准备CREATE TABLE emp( id INT, workno VARCHAR(10), name VARCHAR(10), gender CHAR(1), age TINYINT UNSIGNED, idcard CHAR(18), workaddress VARCHAR(50), entrydate DATE) COMMENT &#x27;员工表&#x27;;DESC emp;INSERT INTO emp VALUES(1, &#x27;1&#x27;, &#x27;aa&#x27;, &#x27;W&#x27;, 28, &#x27;123456789012345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(2, &#x27;2&#x27;, &#x27;ab&#x27;, &#x27;M&#x27;, 18, &#x27;123456789012335678&#x27;, &#x27;Dalian&#x27;, &#x27;2000-01-01&#x27;),(3, &#x27;3&#x27;, &#x27;ac&#x27;, &#x27;M&#x27;, 8, &#x27;123456789012345678&#x27;, &#x27;Beijing&#x27;, &#x27;2006-01-01&#x27;),(4, &#x27;4&#x27;, &#x27;ad&#x27;, &#x27;W&#x27;, 28, &#x27;123456783412345678&#x27;, &#x27;Dalian&#x27;, &#x27;2002-01-01&#x27;),(5, &#x27;5&#x27;, &#x27;ae&#x27;, &#x27;W&#x27;, 38, &#x27;123456783312345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(6, &#x27;6&#x27;, &#x27;af&#x27;, &#x27;M&#x27;, 68, &#x27;123456786012345678&#x27;, &#x27;Dalian&#x27;, &#x27;2000-01-06&#x27;),(7, &#x27;7&#x27;, &#x27;ag&#x27;, &#x27;W&#x27;, 28, &#x27;123456789012445678&#x27;, &#x27;Beijing&#x27;, &#x27;2007-01-01&#x27;),(8, &#x27;8&#x27;, &#x27;ah&#x27;, &#x27;M&#x27;, 8, &#x27;123456789012235678&#x27;, &#x27;Shanghai&#x27;, &#x27;2000-01-01&#x27;),(9, &#x27;9&#x27;, &#x27;ai&#x27;, &#x27;W&#x27;, 28, &#x27;123456789022345678&#x27;, &#x27;Beijing&#x27;, &#x27;2011-01-02&#x27;),(10, &#x27;10&#x27;, &#x27;aj&#x27;, &#x27;W&#x27;, 98, &#x27;123456722212345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(11, &#x27;11&#x27;, &#x27;ak&#x27;, &#x27;M&#x27;, 28, &#x27;123456555512345678&#x27;, &#x27;Shanghai&#x27;, &#x27;2000-01-01&#x27;),(12, &#x27;12&#x27;, &#x27;al&#x27;, &#x27;W&#x27;, 78, &#x27;123456789512345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(13, &#x27;13&#x27;, &#x27;am&#x27;, &#x27;M&#x27;, 16, &#x27;123456789712345678&#x27;, &#x27;Shanghai&#x27;, &#x27;1990-01-01&#x27;),(14, &#x27;14&#x27;, &#x27;an&#x27;, &#x27;W&#x27;, 18, &#x27;123456789872345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(15, &#x27;15&#x27;, &#x27;ao&#x27;, &#x27;M&#x27;, 2, &#x27;123456789012345678&#x27;, &#x27;Shanghai&#x27;, &#x27;2005-01-01&#x27;),(16, &#x27;16&#x27;, &#x27;aq&#x27;, &#x27;W&#x27;, 22, &#x27;123456782362345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;); 123456789101112131415-- 基本查询-- 1. 查询指定字段，name，workno，age返回SELECT name, workno, age FROM emp;-- 2. 查询所有字段返回SELECT * FROM emp; -- 尽量不要写*，因为效率低而且不安全，相比之下写出来所有字段更好SELECT id, workno, name, gender, age, idcard, workaddress, entrydate FROM emp;-- 3. 查询所有员工的工作地址SELECT workaddress as &#x27;工作地址&#x27; FROM emp;SELECT workaddress &#x27;工作地址&#x27; FROM emp;-- 4. 查询员工的上班地址（不要重复）SELECT DISTINCT workaddress &#x27;工作地址&#x27; FROM emp; DQL-条件查询1. 语法 1SELECT 字段列表 FROM 表名 WHERE 条件列表; 2. 条件比较运算符![]逻辑运算符 案例： 123456789101112131415161718192021222324252627-- 条件查询-- 1. 查询年龄等于98的员工SELECT * FROM emp WHERE age = 98;-- 2. 查询年龄小于20 的员工SELECT * FROM emp WHERE age &lt; 20;-- 3. 查询年龄小于等于20的员工信息SELECT * FROM emp WHERE age &lt;= 20;-- 4. 查询没有身份证号的员工信息SELECT * FROM emp WHERE idcard IS NULL;-- 5. 查询有身份证号的员工SELECT * FROM emp WHERE idcard IS NOT NULL;-- 6. 查询年龄不是88的员工SELECT * FROM emp WHERE age &lt;&gt; 88;SELECT * FROM emp WHERE age != 88;-- 7. 查询年龄在15~20岁的员工SELECT * FROM emp WHERE age BETWEEN 15 AND 20;SELECT * FROM emp WHERE age &gt;= 15 AND age &lt;= 20;-- 8. 查询性别为女而且年龄小于25的员工信息SELECT * FROM emp WHERE gender = &#x27;W&#x27; AND age &lt; 25;-- 9. 查询年龄等于18或20或40的员工信息SELECT * FROM emp WHERE age = 18 OR age = 20 OR age = 40;SELECT * FROM emp WHERE age IN (18, 20, 40);-- 10. 查询名字是两个字的员工的信息SELECT * FROM emp WHERE name like &#x27;__&#x27;;-- 11. 查询身份证号最后一位是X的员工信息SELECT * FROM emp WHERE idcard LIKE &#x27;%X&#x27;;SELECT * FROM emp WHERE idcard LIKE &#x27;_________________X&#x27;; DQL-分组查询语法： 1SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件] WHERE和HAVING的区别- 执行时间不同，WHER是分组前过滤，HAVING是分组后过滤- 判断条件不同，WHERE不能对聚合函数进行判断，HAVING可以案例： 1234567-- 分组查询-- 1. 根据性别分组，统计男性员工和女性员工的数量SELECT gender, COUNT(*) total FROM emp GROUP BY gender;-- 2. 根据性别分组，统计男性员工和女性员工的平均年龄SELECT gender, AVG(age) avg_age FROM emp GROUP BY gender;-- 3. 查询年龄小于45的员工，并根据工作地址进行分组，获取员工数量&gt;=3的工作地址SELECT workaddress, COUNT(*) address_count FROM emp WHERE age &lt; 45 GROUP BY workaddress HAVING address_count &gt;= 3; 注意：- 执行顺序：where &gt; 聚合函数 &gt; having- 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无意义DQL-排序查询语法： 1SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： 12ASC: 升序 （默认值）DESC: 降序 案例： 1234567-- 排序查询-- 1 根据年龄对公司的员工进行升序排序SELECT * FROM emp ORDER BY age ASC; -- ASC可以省略；降序则改为DESC-- 2 根据入职时间对员工进行降序排序SELECT * FROM emp ORDER BY entrydate DESC;-- 3 根据年龄对公司员工进行升序排序，如果年龄相同再按入职时间进行降序排序SELECT * FROM emp ORDER BY age ASC, entrydate DESC; DQL-分页查询语法： 1SELECT 字段列表 FROM 表名 LIMIT 起始索, 查询返回记录数; 注意：- 起始索引从0开始，其实索引 &#x3D; (查询页码 - 1) * 每页显示记录数- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL是LIMIT- 如果查询的是第一页的数据，起始索引可以省略，直接简写为LIMIT 10案例： 1234567-- 分页查询-- 1. 查询第一页员工数据，每页显示10条记录SELECT * FROM emp LIMIT 0, 10;SELECT * FROM emp LIMIT 10;-- 2. 查询第二页员工数据，每页显示10条记录SELECT * FROM emp LIMIT 10, 10; -- (页码 - 1)*页展示记录数 DQL 案例课 12345678910-- 案例-- 1. 查询年龄为20，21，22，23岁的女性员工信息SELECT * FROM emp WHERE age IN (20, 21, 22, 23) AND gender = &#x27;W&#x27;;-- 2. 查询性别为男并且年龄在20-40岁（含）且姓名为两个字的员工SELECT * FROM emp WHERE gender = &#x27;M&#x27; AND ( age BETWEEN 20 AND 40 ) AND name LIKE &#x27;__&#x27;;-- 3. 统计员工表中，年龄小于60岁的男性和女性员工的数量。SELECT gender, COUNT(*) age_count FROM emp WHERE age &lt; 60 GROUP BY gender;-- 4. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按照年龄升序排序，年龄相同按照入职时间降序排序SELECT name, age FROM emp WHERE age &lt;= 35 ORDER BY age, entrydate DESC;-- 5. 查询性别为W且年龄在20-40（含）以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按照入职时间升序SELECT * FROM emp WHERE gender = &#x27;W&#x27; AND ( age BETWEEN 20 AND 40 ) ORDER BY age, entrydate LIMIT 5; DQL - 执行顺序 12345678910111213141516171819SELECT (4)FROM (1)WHERE (2)GROUP BY (3)HAVINGORDER BY (5)LIMIT (6)=&gt;FROM WHEREGROUP BYHAVINGSELECTORDER BYLIMIT 案例： 1234567891011-- 查询年龄大于15的员工的姓名、年龄、并根据年龄进行升序排序SELECT name, age FROM emp WHERE age &gt; 15 ORDER BY age;-- 顺序验证SELECT name, age FROM emp E WHERE E.age &gt; 15 ORDER BY age; -- FROM 第一SELECT E.name, E.age FROM emp E WHERE E.age &gt; 15 ORDER BY age; -- SELECT 在FROM和WHERE之后SELECT E.name ename, E.age EAGE FROM emp E WHERE EAGE &gt; 15 ORDER BY age; -- 失败：SELECT 在FROM和WHERE之后执行SELECT E.name ename, E.age EAGE FROM emp E WHERE E.age &gt; 15 ORDER BY EAGE; -- 成功：SELECT 在ORDER BY之前执行 DCL-介绍DCL 全称 Data Control Language （数据控制语言），用来管理数据库用户、控制数据库的访问权限DCL-管理用户1. 查询用户 12USE mysql;SELECT * FROM user; 2. 创建用户 1CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;; 3. 修改用户密码 1ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;; 4. 删除用户 1DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;; 案例： 12345678910111213141516-- DCLuse mysql;show tables;select * from user;-- 创建用户itcast，只能够在localhost 访问，密码123456create user &#x27;itcast&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;-- 创建用户heima，可以在任意机器访问该数据库，密码123456create user &#x27;heima&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;-- 修改用户heima的密码为1234alter user &#x27;heima&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;1234&#x27;;-- 删除itcast@localhost用户drop user &#x27;itcast&#x27;@&#x27;localhost&#x27;; 注意：- 主机名可以用’%‘通配- 这类SQL开发人员使用较少，主要是DBA (Database Administrator 数据库管理员)使用DCL-权限控制 1. 查询权限 1SHOW GRANTS FOR &#x27;用户名&#x27;@‘主机名’; 2. 授予权限 1GRANT 权限列表 ON 数据库.表名 TO &#x27;用户名&#x27;@‘主机名’; 3. 撤销权限 1REMOVE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@‘主机名’; 案例： 12345678-- 查询权限show grants for &#x27;heima&#x27;@&#x27;%&#x27;;-- 授予权限grant all on itcast.* to &#x27;heima&#x27;@&#x27;%&#x27;;-- 撤销权限revoke all on itcast.* from &#x27;heima&#x27;@&#x27;%&#x27;; 注意： 总结：1. 用户管理 123CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;ALTER USER &#x27;usernmae&#x27;@&#x27;host&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;DROP USER &#x27;username&#x27;@&#x27;host&#x27;; 2. 权限控制 12GRANT 权限列表 ON 数据库名.表名 TO ‘用户名&#x27;@&#x27;主机名&#x27;;REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;; 函数函数是指可以被另一段程序直接调用的的程序或代码。 字符串函数 数值函数 日期函数 流程函数 字符串函数演示： 123456789101112131415161718192021-- 函数演示-- concatselect concat(&#x27;Hello &#x27;, &#x27;MySQL&#x27;);-- lowerselect lower(&#x27;Hello&#x27;);-- upperselect upper(&#x27;Hello&#x27;);-- lpadselect lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- rpadselect rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- trimselect trim(&#x27; Hello MySQL &#x27;);-- substringselect substring(&#x27;Hello MySQL&#x27;, 1, 5); # 这里字符串索引从1开始 案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补充0。比如1号员工应该为00001。答案： 1234-- 1. 员工号补0.use itcast;select * from emp;update emp set workno = lpad(workno, 5, &#x27;0&#x27;); 数值函数常见的数值函数如下： 演示 12345678910111213-- 数值函数-- ceilselect ceil(1.1);-- floorselect floor(1.5);-- modselect mod(3, 4); # 3除以4取余select mod(6, 4);-- randselect rand(); # 获得一个0-1的随机数-- roundselect round(2.345, 2);select round(2.344, 2); 案例通过数据库的函数，生成一个六位数的随机验证码 1234-- 2.通过数据库的函数，生成一个六位数的随机验证码selectsubstring(rand(), 3, 6); # 用substring截取select lpad(round(rand() * 1000000, 0), 6, &#x27;0&#x27;); # 计算，取整，填充 日期函数常见的日期函数 演示： 12345678910111213141516-- 日期函数-- curdate()select curdate();-- curtime()select curtime();-- now()select now();-- YEAR, MONTH, DAYselect year(now()), month(now()), day(now());-- date_add(date, INTERVAL expr type)select date_add(now(), INTERVAL 70 day); # 70天之后，70天之前用负值即可-- date_diffselect datediff(now(), &#x27;2022-12-01&#x27;); # 第一个日期减去第二个日期 案例： 12-- 查询所有员工的入职天数，并根据入职天数倒序排序select name, entrydate, datediff(now(), entrydate) 入职日期 from emp order by 入职日期 desc; #可以用中文。 流程函数流程函数实现条件筛选，提高语句的效率： 1234IF(value, t, f)IFNULL(value1, value2)CASE WHEN [val1] THEN [res1] ... ELSE [default] ENDCASE [expr] WHEN [val1] THEN [res1] .. ELSE [default] END 演示： 12345678910111213141516171819-- 流程函数-- ifselect if (true, &#x27;ok&#x27;, &#x27;error&#x27;);-- ifnullselect ifnull (&#x27;ok&#x27;, &#x27;Default&#x27;); -- 第一个值为非null则返回第一个值，若为null则返回第二个值select ifnull (&#x27;&#x27;, &#x27;Default&#x27;);select ifnull (null, &#x27;Default&#x27;);-- case when then else end-- 需求：查询emp员工姓名和工作地址（北京/上海 ---&gt;一线城市，其他---&gt;二线城市）select name, case workaddress when &#x27;Beijing&#x27; then &#x27;一线城市&#x27; when &#x27;Shanghai&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; endfrom emp; 案例： 1234567891011121314151617181920-- 案例：统计班级各个学员的成绩，展示的规则如下：-- &gt;= 85，展示优秀 -- &gt;= 60, 展示及格 -- 否则， 展示不及格 create table score( id int comment &#x27;ID&#x27;, name varchar(20) comment &#x27;姓名&#x27;, math int comment &#x27;数学&#x27;, english int comment &#x27;英语&#x27;, chinese int comment &#x27;语文&#x27;) comment &#x27;学员成绩表&#x27;;insert into scorevalues (1, &#x27;Tom&#x27;, 67, 88, 95), (2, &#x27;Rose&#x27;, 23, 66, 90), (3, &#x27;Jack&#x27;, 56, 98, 76);select * from score;select id, name, case when math &gt;= 85 then &#x27;优秀&#x27; when math between 60 and 85 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;数学成绩&#x27;, case when english &gt;= 85 then &#x27;优秀&#x27; when english between 60 and 85 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;英语成绩&#x27;, case when chinese &gt;= 85 then &#x27;优秀&#x27; when chinese between 60 and 85 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;语文成绩&#x27;from score; 总结字符串函数 1234567concatlowerupperlpad 左填充rpad 右填充trim 去除左右空格substring 字符串截取 数值函数 12345ceilfloormodrandround 四舍五入，保留指定位小数 日期函数 12345678curdatecurtimenowyearmonthdaydate_adddatediff 第一个日期减去第二个日期 流程函数 123ififnullcase [...] when.. then... else... end 约束概述：常见的约束有哪些 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据 目的：保证数据库中数据的正确，有效性和完整性 分类： 约束演示案例：根据需求，完成表的创建 12345678910111213141516171819202122232425262728293031id: primary key, auto_incrementname: not null, uniqueage: checkstatus: defaultgender: N/A-- 约束create database itheima default charset utf8mb4;use itheima;create table user( id int primary key auto_increment comment &#x27;主键&#x27;, name varchar(10) not null unique comment &#x27;姓名&#x27;, age int check(age &gt; 0 and age &lt; 120) comment &#x27;年龄&#x27;, -- 用and或&amp;&amp;都可以 status char(1) default &#x27;1&#x27; comment &#x27;状态&#x27;, gender char(1)) comment &#x27;用户表&#x27;;select * from user;insert into user(name, age, status, gender) values (&#x27;Tom1&#x27;, 19, &#x27;1&#x27;, &#x27;男&#x27;), (&#x27;Tom2&#x27;, 25, &#x27;0&#x27;, &#x27;男&#x27;);insert into user(name, age, status, gender) values (&#x27;Tom3&#x27;, 19, &#x27;1&#x27;, &#x27;男&#x27;);insert into user(name, age, status, gender) values (null, 19, &#x27;1&#x27;, &#x27;男&#x27;); -- 出错，因为不可以出错insert into user(name, age, status, gender) values (&#x27;Tom3&#x27;, 19, &#x27;1&#x27;, &#x27;男&#x27;); -- 不可重复执行，因为存在唯一约束 insert into user(name, age, status, gender) values (&#x27;Tom4&#x27;, 80, &#x27;1&#x27;, &#x27;男&#x27;); -- id 是5，虽然刚才插入没有成功，但是id已经被申请过了 insert into user(name, age, status, gender) values (&#x27;Tom5&#x27;, -1, &#x27;1&#x27;, &#x27;男&#x27;); -- 检查约束生效 insert into user(name, age, status, gender) values (&#x27;Tom5&#x27;, 121, &#x27;1&#x27;, &#x27;男&#x27;); -- 检查约束生效 insert into user(name, age, gender) values (&#x27;Tom6&#x27;, 121, &#x27;男&#x27;);insert into user(name, age, gender) values (&#x27;Tom5&#x27;, 120, &#x27;男&#x27;); 拓展：约束的修改 12345-- 发现建表的时候约束设置的不正确,如何修改 show create table user; -- 查看现有约束的名称alter table user drop constraint user_chk_1; -- 删除现有约束delete from user where age = 121; -- 如果有数据不满足约束,去除之 alter table user add constraint user_chk_1 check (age &gt; 0 and age &lt;= 120); -- 添加新的约束,操作结束 外键约束概念外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性 具有外键的表称为子表，被关联的表叫做父表注意：数据库层面，未建立外键关联，所以无法保证数据的一致性和完整性。演示： 12345678910111213141516171819202122232425262728-- 外键约束 -- 准备数据create table dept( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;部门名称&#x27;) comment &#x27;部门表&#x27;; insert into dept (id, name) values (1, &#x27;研发部&#x27;), (2, &#x27;市场部&#x27;), (3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;);create table emp ( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;姓名&#x27;, age int comment &#x27;姓名&#x27;, job varchar(20) comment &#x27;职位&#x27;, salary int comment &#x27;薪资&#x27;, entrydate date comment &#x27;入职时间&#x27;, managerid int comment &#x27;直属领导ID&#x27;, dept_id int comment &#x27;部门ID&#x27;) comment &#x27;员工表&#x27;;insert into emp (name, age, job, salary, entrydate, managerid, dept_id) values (&#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5), (&#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),(&#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1), (&#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),(&#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1), (&#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1);select * from emp;select * from dept;-- 以上,没有设置物理外键,无法保证数据之间的一致性和完整性 语法：添加外键 1234567891011121314151617181920CREATE TABLE 表名( 字段名 数据类型, .. [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);案例：delete from dept where id = 1; -- 成功删除 insert into dept (id, name) values (1, &#x27;研发部&#x27;);-- 添加外键 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);commit;delete from dept where id = 1; -- Cannot delete or update a parent row: a foreign key constraint fails-- 删除外键 alter table emp drop foreign key fk_emp_dept_id;delete from dept where id = 1; -- 删除成功 删除&#x2F;更新行为 123ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段）REFERENCES 主表 （主表字段名）ON UPDATE CASCADE ON DELETE CASCADE; 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758-- 外键的删除和更新行为 alter table emp add constraint fk_emp_dept_idforeign key(dept_id) references dept(id)on update cascade on delete cascade; -- 级联更新/删除 -- 级联更新操作 select * from dept;update dept set id = 6 where name = &#x27;研发部&#x27;;commit;select * from emp; -- 查看子表，的确更新为6了，这就是cascade的作用 delete from dept where id = 6; -- 子表数据也被删除了 -- SET NULL 操作 drop table emp;drop table dept;-- 准备数据create table dept( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;部门名称&#x27;) comment &#x27;部门表&#x27;; insert into dept (id, name)values (1, &#x27;研发部&#x27;),(2, &#x27;市场部&#x27;), (3, &#x27;财务部&#x27;),(4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;);create table emp ( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;姓名&#x27;, age int comment &#x27;姓名&#x27;, job varchar(20) comment &#x27;职位&#x27;, salary int comment &#x27;薪资&#x27;, entrydate date comment &#x27;入职时间&#x27;, managerid int comment &#x27;直属领导ID&#x27;, dept_id int comment &#x27;部门ID&#x27;) comment &#x27;员工表&#x27;;insert into emp (name, age, job, salary, entrydate, managerid, dept_id)values (&#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),(&#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),(&#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),(&#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),(&#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),(&#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1);select * from dept;select * from emp;-- 添加外键 alter table emp add constraint fk_emp_dept_id foreign key(dept_id)references dept(id) on update set null on delete set null; -- set null更新/删除 -- 删除id = 1的数据delete from dept where id = 1;select * from emp; -- 可见所有emp 原有dept_id = 1的数据现在 dept_id的值为 null 总结1. 非空约束 not null2. 唯一约束 unique3. 主键约束 primary key (自增: AUTO_INCREMENT， ORACLE没有这个，而是SEQUENCE)4. 默认约束 default5. 检查约束 check6. 外键约束 foreign key多表查询多表关系各个表结构之间存在各种联系：一对多 （多对一）多对多一对一一对多（多对一）案例：部门 与 员工 的关系关系：一个部门对应多个员工，一个员工对应一个部门实现：再多的一方建立外键，只想一的一方的主键 多对多案例：学生 与 课程的关系关系：一个学生可以选择多门课程，一门课程也可以供多个学生选择实现：建立第三张中间表，中间层至少包含两个外键，分别关联两方主键 案例： 1234567891011121314151617181920212223242526272829303132333435-- 多对多 -- 学生表create table student ( id int auto_increment primary key comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;姓名&#x27;, no varchar(10) comment &#x27;学号&#x27;) comment &#x27;学生表&#x27;;insert into studentvalues (null, &#x27;黛绮丝&#x27;, &#x27;2000100101&#x27;),(null, &#x27;谢逊&#x27;, &#x27;2000100102&#x27;),(null, &#x27;殷天正&#x27;, &#x27;2000100103&#x27;),(null, &#x27;韦一笑&#x27;, &#x27;2000100104&#x27;);-- 课程表 create table course( id int auto_increment primary key comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;课程名称&#x27;) comment &#x27;课程表&#x27;;insert into course values (null, &#x27;Java&#x27;), (null, &#x27;PHP&#x27;), (null, &#x27;MySQL&#x27;), (null, &#x27;Hadoop&#x27;);-- 学生课程关系表 create table student_course( id int auto_increment comment &#x27;主键&#x27; primary key, studentid int not null comment &#x27;学生ID&#x27;, courseid int not null comment &#x27;课程ID&#x27;, constraint fk_courseid foreign key (courseid) references course (id), constraint fk_student_id foreign key (studentid) references student(id)) comment &#x27;学生课程中间表&#x27;;insert into student_course values (null, 1, 1), (null, 1, 2), (null, 1, 3), (null, 2, 2), (null, 2, 3), (null, 3, 4);describe student_course;select * from studenstudent_coursestudent_coursestudent_coursestudent_coursestudent_courset_course; .一对一案例：用户 和 用户详情的关系关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）图例：![] 案例： 12345678910111213141516171819202122232425262728293031-- 一对一create table tb_user ( id int auto_increment primary key comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender char(1) comment &#x27;1: 男，2: 女&#x27;, phone char(11) comment &#x27;手机号&#x27;) comment &#x27;用户基本信息表&#x27;;create table tb_user_edu ( id int auto_increment primary key comment &#x27;主键ID&#x27;, degree varchar(20) comment &#x27;学历&#x27;, major varchar(50) comment &#x27;专业&#x27;, primaryschool varchar(50) comment &#x27;小学&#x27;, middleschool varchar(50) comment &#x27;中学&#x27;, university varchar(50) comment &#x27;大学&#x27;, userid int UNIQUE comment &#x27;用户ID&#x27;, constraint fk_userid foreign key (userid) references tb_user(id)) comment &#x27;用户教育信息表&#x27;;insert into tb_user(id, name, age, gender, phone) values(null, &#x27;黄渤&#x27;, 45, &#x27;1&#x27;, &#x27;18800001111&#x27;),(null, &#x27;冰冰&#x27;, 35, &#x27;2&#x27;, &#x27;18800002222&#x27;),(null, &#x27;码云&#x27;, 55, &#x27;1&#x27;, &#x27;18800008888&#x27;),(null, &#x27;李彦宏&#x27;, 50, &#x27;1&#x27;, &#x27;18800009999&#x27;);insert into tb_user_edu values(null, &#x27;本科&#x27;, &#x27;舞蹈&#x27;, &#x27;青岛市第一小学&#x27;, &#x27;青岛市第一中学&#x27;, &#x27;北京电影学院&#x27;, 1),(null, &#x27;硕士&#x27;, &#x27;表演&#x27;, &#x27;朝阳区第一小学&#x27;, &#x27;朝阳区第一中学&#x27;, &#x27;上海戏剧学院&#x27;, 2),(null, &#x27;本科&#x27;, &#x27;英语&#x27;, &#x27;杭州市第一小学&#x27;, &#x27;杭州市第一中学&#x27;, &#x27;杭州示范大学&#x27;, 3),(null, &#x27;本科&#x27;, &#x27;计算机&#x27;, &#x27;阳泉第一小学&#x27;, &#x27;阳泉第一中学&#x27;, &#x27;清华大学&#x27;, 4); 多表查询概述概述：指从多张表中查询数据笛卡尔积：指在数学中，两个集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 案例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 数据准备 drop table emp;drop table dept;create table dept( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;部门名称&#x27;) comment &#x27;部门表&#x27;; insert into dept (id, name) values (1, &#x27;研发部&#x27;),(2, &#x27;市场部&#x27;), (3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;),(5, &#x27;总经办&#x27;), (6, &#x27;人事部&#x27;);create table emp ( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;姓名&#x27;, age int comment &#x27;姓名&#x27;, job varchar(20) comment &#x27;职位&#x27;, salary int comment &#x27;薪资&#x27;, entrydate date comment &#x27;入职时间&#x27;, managerid int comment &#x27;直属领导ID&#x27;, dept_id int comment &#x27;部门ID&#x27;) comment &#x27;员工表&#x27;;insert into emp (name, age, job, salary, entrydate, managerid, dept_id)values(&#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),(&#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),(&#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),(&#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),(&#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),(&#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1),(&#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;, 8500, &#x27;2002-10-12&#x27;, 1, 1),(&#x27;周芷若&#x27;, 19, &#x27;会计&#x27;, 48000, &#x27;2006-10-12&#x27;, 7, 3),(&#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;, 5250, &#x27;2009-10-12&#x27;, 7, 3),(&#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;, 12500, &#x27;2004-10-12&#x27;, 1, 2),(&#x27;路障可&#x27;, 56, &#x27;职员&#x27;, 3750, &#x27;2006-10-12&#x27;, 10, 2),(&#x27;和笔翁&#x27;, 19, &#x27;职员&#x27;, 3750, &#x27;2007-10-12&#x27;, 10, 2),(&#x27;房东白&#x27;, 19, &#x27;职员&#x27;, 5500, &#x27;2009-10-12&#x27;, 102, 2),(&#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;, 14000, &#x27;2004-10-12&#x27;, 1, 4),(&#x27;玉莲舟&#x27;, 38, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),(&#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),(&#x27;陈友谅&#x27;, 42, &#x27;null&#x27;, 2000, &#x27;2011-10-12&#x27;, 1, null);alter table emp add constraint foreign key fk_deptid (dept_id)references dept(id);-- 多表查询 select * from emp, dept; -- 查出来的结果好像比想象中要多 - 笛卡尔积 17 * 6 = 102 条select * from emp, dept where emp.dept_id = dept.id; 多表查询分类- 连接查询 - 内连接: 相当于查询A.B交集部分的数据 外连接: 左外连接: 查询左表中的所有数据，以及交集部分数据 右外连接：查询右表中的所有数据，以及交集部分数据 自连接：当前表与自身的连接查询，自连接必须使用表别名\\ 子查询内连接内连接查询语法： 隐式内连接： 1select 字段列表 from 表1, 表2 where 条件...; 显式内连接： 1select 字段列表 from 表1 [INNER] join 表2 on 连接条件...; 案例： 12345678910-- 内连接演示-- 1. 查询每一个员工的姓名,以及关联的部门的名称 (隐式内连接实现) select e.name, d.name from emp e, dept d where e.dept_id = d.id; -- 起别名之后不能直接用表名访问字段了 select emp.name, dept.name from emp, dept where emp.dept_id = dept.id;-- 2. 查询每一个员工的姓名以及关联的部门名称(显式内连接实现) select e.name, d.name from emp e inner join dept don e.dept_id = d.id; 外连接语法： 左外： 1select 字段名 from 表1 left [outer] join 表2 on 条件... ; 右外： 1select 字段名 from 表1 right [outer] join 表2 on 条件... ; 案例： 12345678910-- 外连接演示 -- 1. 查询emp表所有数据， 和对应的部门信息 （左连接）select e.*, d.name from emp e left join dept d on e.dept_id = d.id;select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;-- 2. 查询dept表中所有数据，和对应的员工信息 （右连接） select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;-- 等价于：select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id; 自连接语法： 1select 字段列表 from 表A 别名A join 表A 别名B on 条件... ; 自联结查询可以是内连接也可以是外连接案例： 12345678910-- 内连接演示 -- 1. 查询员工及其所属的领导名字 -- 表结构：emp表select a.name employee, b.name manager from emp a, emp bwhere a.managerid = b.id;-- 2. 查询所有员工emp及其领导的名字emp，如果员工没有领导也需要查询出来 -- 表结构：emp e1, emp e2select e1.name employee, e2.name boss from emp e1left join emp e2 on e1.managerid = e2.id; -- 左外 联合查询关键字：union, union all语法： 123select 字段列表 表A ...UNION [ALL]select 字段列表 表B ... ; 案例： 1234567-- union all, union-- 1. 将薪资低于5000的员工，和年龄大于50的员工全部查询出来 select * from emp where salary &lt; 5000union # union合并后去重，union all则没有去重 select * from emp where age &gt; 50;# 如果第二个查询只查询name，则无法使用union因为列数量不同 小结： 联合查询多张表的列数必须保持一致，字段类型也必须一致 union all 直接合并，union则会去重 子查询概念：SQL语句中嵌套SELECT语句，成为嵌套查询，又称子查询语法： 1select * from t1 where column1 = (select column1 from t2); 注意 - 子查询外部语句可以是insert&#x2F;update&#x2F;delete&#x2F;select的任何一个。分类：子查询结果不同，可以分为： 标量子查询 （子查询结果为单个值） 列子查询 （子查询结果为一列） 行子查询 （子查询结果为一行） 表子查询 （子查询结果为多行多列）根据子查询位置，分为：WHERE之后，FROM之后，SELECT之后。标量子查询：概念：子查询返回结果为单个值（数字，字符串，日期等），最简单的形式，这种子查询称为标量子查询。常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;案例： 12345678910111213141516171819202122-- 标量子查询 -- 1. 查询销售部所有员工信息 -- a. 查询销售部部门idselect id from dept where name = &#x27;销售部&#x27;;-- b. 根据部门id查询员工信息 select * from emp where dept_id = 4;-- 使用子查询 select * from emp where dept_id =(select id from dept where name = &#x27;销售部&#x27;);-- 使用外连接 select e.* from emp e join dept d on e.dept_id = d.idwhere d.name = &#x27;销售部&#x27;;-- 2. 查询在“房东白”入职之后的员工信息 -- a. 查询房东白的入职时间 select entrydate from emp where emp.name = &#x27;房东白&#x27;;-- b. 查询比房东白入职晚的员工 select * from emp where entrydate &gt; &#x27;2009-10-12&#x27;;-- 使用子查询 select * from emp where entrydate &gt;(select entrydate from emp where name = &#x27;房东白&#x27;); 列子查询：概念：子查询返回的结果是一列（可以是多行），这种子查询称为列子查询常用的操作符：IN, NOT IN, ANY, SOME, ALL 案例： 123456789101112131415161718192021222324252627282930313233-- 列子查询 -- 1. 查询“销售部”和“市场部”的所有员工信息 -- a. 找到销售部和市场部的部门idselect id from dept where name in (&#x27;销售部&#x27;, &#x27;市场部&#x27;);-- b. 根据部门id，查询员工信息 select * from emp where dept_id in(select id from dept where name in (&#x27;销售部&#x27;, &#x27;市场部&#x27;));-- 2. 查询比财务部所有人工资都高的员工信息-- 标量子查询 select * from emp a where salary &gt; ( select max(salary) from emp where dept_id in(select id from dept where name = &#x27;财务部&#x27;));-- 列子查询 select * from emp where salary &gt; all (select salary from emp where dept_id in(select id from dept where name = &#x27;财务部&#x27;));-- 3. 比研发部任意一人工资高的员工信息 -- 列子查询 select * from emp where salary &gt; any (select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;));-- 标量子查询select * from emp where salary &gt; (select min(e.salary) from emp e join dept d on e.dept_id = d.idwhere d.name = &#x27;研发部&#x27;); 行子查询概念：子查询返回的结果是一行（多列的）常用操作符：&#x3D;, &lt;&gt;, IN, NOT IN案例： 1234-- 行子查询 -- 查询与张无忌薪资和直属领导相同的员工信息 select * from emp where (salary, managerid) = (select salary, managerid from emp where name = &#x27;张无忌&#x27;); 表子查询概念：子查询返回的结果是多行多列，这种子查询叫做表子查询常用操作符：IN案例： 1234567891011-- 表子查询 -- 1. 查询与路障可，宋远桥的职位和薪资相同的员工 select * from emp where (job, salary) in (select job, salary from emp where name in (&#x27;路障可&#x27;, &#x27;宋远桥&#x27;));-- 2. 查询入职日期是“2006-01-01”之后的员工信息及其部门信息 select a.*, b.* from dept a right join(select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;) bon a.id = b.dept_id; 多表查询案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120-- 多表查询案例 create table salgrade ( grade int, losal int, hisal int) comment &#x27;薪资等级表&#x27;;insert into salgrade values(1, 0, 3000),(2, 3001, 5000),(3, 5001, 8000),(4, 8001, 10000),(5, 10001, 15000),(6, 15001, 20000),(7, 20001, 25000),(8, 25001, 30000);-- 1. 查询员工的姓名，年龄，职位，部门信息（隐式内连接） select e.name, e.age, e.job, d.name from emp e, dept dwhere e.dept_id = d.id;-- 2. 查询年龄小于30岁的员工的姓名，年龄，职位，部门信息（显式内连接） select e.name, e.age, e.job, d.namefrom emp e join dept don e.dept_id = d.idwhere e.age &lt; 30;-- 3. 查询拥有员工的部门的id，部门名称 select distinct d.id, d.name from dept dinner join emp eon e.dept_id = d.id;-- 4. 查询年龄大于40岁的员工，及其归属的部门名称；如果员工没有部门，也要展示出来 select e.*, d.name from emp e left join dept don e.dept_id = d.idwhere e.age &gt; 40;-- 5. 查询所有员工的工资等级 select e.*, sg.grade, sg.losal, sg.hisal fromemp e left join salgrade sgon e.salary &gt;= sg.losal and e.salary &lt;= sg.hisal;select e.*, sg.grade fromemp e, salgrade sgwhere e.salary between sg.losal and sg.hisal;-- 6. 查询研发部所有员工的信息及工资等级 select d.name, e.*, sg.grade fromemp e join salgrade sg join dept don e.salary between sg.losal and sg.hisaland e.dept_id = d.idwhere d.name = &#x27;研发部&#x27;;SELECT d.name, e.*, sg.gradeFROM emp e, dept d, salgrade sgWHERE e.salary BETWEEN sg.losal AND sg.hisal AND e.dept_id = d.id AND d.name = &#x27;研发部&#x27;;-- ctrl + B -- 7. 查询研发部的员工的平均工资 select avg(e.salary) &#x27;研发部平均工资&#x27; from emp e, dept dwhere e.dept_id = d.idand d.name = &#x27;研发部&#x27;;-- 8. 查询工资比灭绝高的员工信息 -- 自连接 select e2.* from emp e1, emp e2where e1.name = &#x27;灭绝&#x27;and e2.salary &gt; e1.salary;-- 子查询select * from emp where salary &gt; (select salary from emp where name = &#x27;灭绝&#x27;);-- 9. 查询比平均薪资高的员工信息 select * from emp where salary &gt; (select avg(salary) from emp);-- 10. 查询低于本部门平均薪资的员工 select e.*, avgsal.sal from emp e join (select dept_id, avg(salary) sal from emp group by dept_id) avgsalon e.dept_id = avgsal.dept_idwhere e.salary &lt; avgsal.sal;-- 可以用子查询，目测效率更低因为对于每一行子查询都需要重新计算一下本部门平均薪资 -- 第一步：计算本部门平均薪资：select avg(salary) from emp where dept_id = 1;select * from emp e2 where e2.salary &lt;(select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id);-- 11. 查询所有部门信息并统计部门的员工人数 select count(e.dept_id), d.name from emp e right join dept don e.dept_id = d.idgroup by d.id;-- 子查询-- 第一步，计算每个部门的人数 select count(*) from emp e where e.dept_id = 1;-- 第二步，得出结果 select d.id, d.name, (select count(*) from emp ewhere e.dept_id = d.id) &#x27;人数&#x27; from dept d;-- 12. 查询所有学生的选课情况，展示出学生名称，学号，课程名称 select s.name &#x27;姓名&#x27;, s.no &#x27;学号&#x27;, c.name &#x27;课程名称&#x27; fromstudent s, course c , student_course scwhere s.id = sc.studentidand sc. courseid = c.id;select * from student_course;select * from student;select * from course; 多表查询-总结1. 多表关系多表之间的关系分为三类： 一对多：在多的一方设置外键，关联一的一方的主键 多对多：建立中间表，中间表包含两个外键，关联两张表的主键 一对一：用于表结构拆分，在其中任何一方设置外键（UNIQUE)，关联另一方的主键 （一对一注：xx_order与xx_order_det就是这样的关系） 2. 多表查询内连接 隐式： 1select * from 表A, 表B where 条件....; 显式： 1select * from 表A inner join 表B on 条件.....; 外连接 左外： 1select ... from 表A left join 表B on 条件...; 右外： 1select ... from 表A right join 表B on 条件...; 自连接： 1select * from 表A 别名1, 表B 别名2 where 条件...; 子查询：标量子查询，列子查询，行子查询，表子查询。事务事务简介事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。注意：默认MySQL的事务是自动提交的，即当执行一条DML语句，MySQL会隐式的提交事务。事务操作案例： 12345678910111213141516171819202122232425-- 事务操作 -- 数据准备 create table account ( id int primary key auto_increment comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;姓名&#x27;, money int comment &#x27;余额&#x27;) comment &#x27;账户表&#x27;;insert into accountvalues (null, &#x27;张三&#x27;, 2000), (null, &#x27;李四&#x27;, 2000);-- 恢复数据 update account set money = 2000;-- 转账操作 -- 1. 查询张三的余额 select * from account where name = &#x27;张三&#x27;;-- 2. 将张三的账户余额减去1000 update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;select * from account; 事务操作方式一：查看&#x2F;设置事务的提交方式 12select @@autocommit;set @@autocommit = 0; -- 将提交方式改为手动 提交事务 1commit; 回滚事务 1rollback; 案例： 12345678910111213141516171819set @@autocommit = 0;select @@autocommit;-- 恢复数据 update account set money = 2000;-- 转账操作 -- 1. 查询张三的余额 select * from account where name = &#x27;张三&#x27;;-- 2. 将张三的账户余额减去1000 update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;commit;rollback;select * from account; 事务操作方式二：开启事务 1start transaction 或者 begin 提交事务 1commit 回滚事务 1rollback 案例： 123456789101112131415161718-- 方式2select @@autocommit;set @@autocommit = 1;begin; -- 事务开始 -- 1. 查询张三的余额 select * from account where name = &#x27;张三&#x27;;-- 2. 将张三的账户余额减去1000 update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;commit; -- 提交事务rollback; -- 回滚事务 commit 之前： commit 之后： 出错了就rollback事务四大特性（ACID）原子性 A - atomicity 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。一致性 C - consistency 事务完成时，必须使所有数据都保持一致隔离性 I - isolation 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境运行持久性 D - durability 事务一旦提交或回滚，它对数据库中数据的修改就是永久的并发事务问题 问题描述脏读一个事务读取到另一个事务未提交的数据不可重复读一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读幻读一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，发现这行数据已经存在了，好像出现了”幻影“。 事务隔离级别 隔离级别脏读不可重复读幻读Read uncommittedallowallowallowRead commiited (Oracle 默认）noallowallowRepeatable Read (MySQL 默认）nonoallowSerializablenonono 查看事务隔离级别： 1select @@transaction_isolation; 设置事务隔离级别： 12set [session|global] transaction isolation level&#123;read uncommitted | read committed | repeatable read | serializable&#125; 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- 设置事务隔离级别案例 -- 演示脏读 set session transaction isolation level read uncommitted;begin;select * from account; -- id = 1, money = 2000;-- 新开个session，执行# start transaction# update account set money = 2001 where id = 1;select * from account; -- 发现数据更新了 money = 2001commit;-- 演示不可重复读 -- 在一个事务里修改隔离级别是不会起作用的 set session transaction isolation level read committed;begin;select * from account; -- 发现数据是没有更新的 money = 2000;-- 新开的session里执行# commitselect * from account; -- 发现数据更新了 money = 2001;commit;-- 演示可重复读 set session transaction isolation level repeatable read;begin;select * from account; -- id = 1, money = 2001-- 新开的session里执行 # being# update account set money = 2005 where id = 1;# commit;select * from account; -- 发现数据没有更新 money = 2001commit;select * from account; -- 这时候在上一个事务之外，读到了 money = 2005-- 演示幻读 begin;select * from account; -- 这时候只读到两条数据 -- 在新session里执行 # begin;# insert into account values (3, &#x27;王五&#x27;, 2000);# commit;insert into account values (3, &#x27;王五&#x27;, 2000); -- 执行失败，原因是新session读已提交 select * from account; -- 依然读不到 id为3的数据，称之为幻读 commit;-- 演示串行化 delete from account where id = 3;set session transaction isolation level serializable;begin;select * from account; -- 这时候只读到两条数据 -- 在新开session里执行 # begin;# insert into account values (3, &#x27;王五&#x27;, 2000);# 发现新session卡住了，不能动弹 commit;# 发现新session里的insert执行完成了。 注意：事务隔离级别越高，数据越安全，但是效率也越低。总结：1. 事务简介事务是一组操作的集合，一荣俱荣，一损俱损2. 事务操作 12start transaction; 或者 begin; -- 开启事务commit/rollback; -- 提交/回滚 事务3. 事务四大特性原子性A、一致性C、隔离性I、持久性D4. 并发事务问题脏读、不可重复读、幻读5. 事务隔离级别read uncommitted, read committed, repeatable read, serializable基础篇总结MySQL概述 - SQL -函数 - 约束 - 多表查询 - 事务 转载自本人公众号笔记：MySQL数据库 - 基础篇，归类为原创。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xqtony.github.io/tags/MySQL/"},{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"}]}]