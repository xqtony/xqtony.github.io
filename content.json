[{"title":"经验贴：Spring Bean的scope你真的会用吗？","date":"2023-09-26T12:18:00.661Z","path":"2023/09/26/spring-bean-prototype-issue/","text":"我们知道Spring中的Bean默认都是单例的，也就是singleton。另外一个常用的是prototype（原型），可以通过它实现多例模式。但是请问，直接使用@Scope注解加上prototype直接就能实现多例吗？参考下面的代码： MyService Bean: 123@Service@Scope(value=&quot;prototype&quot;)public class MyService MyController Bean: 1234567891011@RestController@RequestMapping(/rest)public class MyController &#123; @Autowired private MyService service; private static int num=0; @GetMapping(&quot;scope1&quot;) public void testScope1()&#123; System.out.println(&quot;num:&quot;+ ++num +&quot;次请求,&quot;+ service); &#125;&#125; 上面定义了两个Bean，一个是服务，一个是控制器。我们把服务通过自动注入的方式注入控制器。 请问上面的实现方式可以确保实现多例模式吗？ 有的朋友可能认为，我已经使用了@Scope(value=&quot;prototype&quot;)，理当直接就是多例模式，每次访问&#x2F;rest&#x2F;me API的时候都能创建新的Bean，打印不同的结果。但是事实真的如此吗？ 实际上看到的输出是： 12num:1次请求,com.xqtony.bean.scope.prototype.service.MyService@6bc394d2num:2次请求,com.xqtony.bean.scope.prototype.service.MyService@6bc394d2 实际上，并没有实现多例！我们的运行结果会发现，两次请求打印出来的结果是一样的。原因是什么？是因为我们没有指定ScopeProxyMode。 ScopeProxyMode的值有: Default, NO, TARGET_CLASS, INTERFACE。 如果希望在这个例子中实现多例，必须加上ScopeProxyMode.TARGET_CLASS。 MyService Bean: 123@Service@Scope(value=&quot;prototype&quot;, proxyMode=ScopedProxyMode.TARGET_CLASS)public class MyService2 这时候会发现，service2和service一个是新创建了对象，另一个没有。 1234num:0次请求, service没加 ScopeProxyModecom.xqtony.bean.scope.prototype.service.MyService@2a80117cnum:0次请求, service加了 ScopeProxyMode.TARGET_CLASScom.xqtony.bean.scope.prototype.service.MyService2@203f807anum:1次请求, service没加 ScopeProxyModecom.xqtony.bean.scope.prototype.service.MyService@2a80117cnum:1次请求, service加了 ScopeProxyMode.TARGET_CLASScom.xqtony.bean.scope.prototype.service.MyService2@391e383e 为什么我们知道要使用TARGET_CLASS呢？因为proxyMode的默认值是Default，而在源码中是这样描述的： 1234567891011121314/** * Default typically equals &#123;@link #NO&#125;, unless a different default * has been configured at the component-scan instruction level. */DEFAULT,/** * Do not create a scoped proxy. * &lt;p&gt;This proxy-mode is not typically useful when used with a * non-singleton scoped instance, which should favor the use of the * &#123;@link #INTERFACES&#125; or &#123;@link #TARGET_CLASS&#125; proxy-modes instead if it * is to be used as a dependency. */NO, 可见在使用Prototype（原型）的时候，是不应该使用DEFAULT的。 完整的项目代码请参考我的代码仓库： Github项目地址 参考：springboot中怎么获取多例（prototype）spring的scope为prototype的bean的正确使用方法","tags":[{"name":"Spring","slug":"Spring","permalink":"https://xqtony.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://xqtony.github.io/tags/Spring-Boot/"},{"name":"Spring Bean","slug":"Spring-Bean","permalink":"https://xqtony.github.io/tags/Spring-Bean/"},{"name":"Prototype","slug":"Prototype","permalink":"https://xqtony.github.io/tags/Prototype/"}]},{"title":"AWS Certified Solution Architect Associate SAA-C03 笔记 (一)","date":"2023-06-26T16:50:59.881Z","path":"2023/06/27/AWS Certified Solution Architect Associate SAA-C03 part1 copy/","text":"最近花了相当长的时间在Pluralsight平台上学习AWS助理架构师的课程。下面是上课记得一些笔记，对于入门和复习都有很大帮助，欢迎阅读。 本篇是第一篇，涵盖了AWS基础，IAM，S3，EC2等内容。 持续更新中… AWS FundamentalsThe Building Blocks of AWS: Availability Zones and RegionsRegion: 2+ AZAZ: 独立机房Edge Locations：CloudFront、AWS CDN 内容分发网络 Who Owns What in the Cloud?toll 过路费charge a toll for the use of (a bridge or road): Compute, Storage, Databases, and NetworkingCompute:EC2, Lambda, EBStorage:S3, Elastic Block Store (EBS), Elastic File Server (EFS), FSx, Stroage GatewayDatabases:RDS, DynamoDB, RedshiftNetworking:VPCs (Virtual DC), Direct Connect, Route 53 (DNS), API Gateway, AWS Global Accelerator What Is the Well-Architected Framework?AWS Witepapers &amp; Guide:考试前必读。Operational Excellence, Performance Efficiency, Security, Cost Optimization, Reliability, Sustainability AWS Fundamentals Exam TipsReview: Region: 2+AZAZ: different dcEdge locations: AWS CDN, (CloudFront) Responsibility:SG, IAM, patching EC2, patching DB on EC2, etcMgmt DC, sec came, etc Key Services:Compute: EC2, Lam, EBStorage: S3, EBS, EFS, FSx, SGDB: RDS, DDB, RsNet: VPCs, DirC, R53, ApiG, AGA Whitepaper reading. Identity and Access Management (IAM)Securing the Root AccountIAM:Create userCreate groups and rolesControl access to AWS resources Permanent IAM CredentialsPowerUser除了不能搞IAM其他和Admin一样IAM全球Root全能，不日用新用户默认无权限Access Key ID是编程用的新用户密码等只能看一次设置密码轮换是必要的IAM Federation 可以用LDAPId Federation 也能用LDAP，SMAL协议。 IAM Exam Tips4安全方法：1 Root MFA2 Admin组创建，分配权限3 创建Admin用户4 Admin用户加入到Admin组 IAM JSON考点：IAM是全球的Root全能，不日用New User无权限Access key ID和secret access key不是用户名密码；是编程用的密码等只能看一次密码轮换是必要的IAM自治：可以复用现有账户ID 自治： 添加SAML标准的Active Dir。(LDAP) Simple Storage Service (S3)S3 OverviewS3目录S3对象存储任意文件类型无法用来跑OS或者DB。仅仅是静态存储。S3 基本无线容量单个文件最大5TBS3 Buckets概念。（buckets类似文件夹）S3 Bucket名字注册在全局命名空间，全球唯一举例https://bucket名称.s3.region.amazonaws.com/key-name文件上传，成功则返回200 CodeS3 Overview：Key： Object nameVersion ID: important for multiple versionValue: data it self, byte arrayMetadata: data about the dataS3 is a safe place to store.Availability and durabilityHighly available and Highly durableBuild for 99.95% - 99.99% service availability, depends on S3 tier11 9 durability. S3 Standard HAD99.99% avail11 9’s dur Designed for frequent access suitable for most workloads. default storage class websites, content distribution, mobile and gaming, etc.3大特性：Tiered Storage 分级存储Lifecycle Management 生命周期管理Versioning 版本安全： 服务端加密 ACLs （访问控制列表） Bucket policies 桶策略RAW 一致性成功写操作之后，读可以正确读取Strong consistency 强一致性考点： 基于对象2 非OS&#x2F;DB存储3 至高5TB4 无限容量5 s3是全局命名空间6 成功文件上传返回200S3对象Tips：Key： 对象名称Value： 数据本身Version ID：版本号Metadata：元数据 Securing Your Bucket with S3 Block Public Access我忘记过Version IDObject ACLs vs Bucket PoliciesOA: 单个对象级别的权限控制BP：整个Bucket级别创建Bucket是Global的，不单独针对区域。 Hosting a Static Website Using S3S3可以serve静态网页。S3自动缩放大小考点：静态网页 -》联想到S3BP： 让整个bucket公共，使用Bucket PolicyStatic Only：只能搞静态网页。有数据库链接的不行。自动扩容：S3可以自动扩容。考点：1 默认私有buckets2 ACLs 单个权限3 Bucket Policy 整个bucket权限4 HTTP 200 表明上传完成 Versioning Objects in S3版本控制优势：全版本保留备份无法关闭（只能暂停）生命周期MFA支持delete marker5个技巧：All Versions 全版本保留备份无法关闭（一旦打开）生命周期规则支持MFA S3 Storage ClassesS3 存储分类标准standard-infrequent AccessOne Zone-infrequent AccessIntelligent-Tiering3 Glacier..S3标准高可用行高持久性高频访问适用大多数负载考点：视频网站：存储视频，图片用S3标准静态网站，使用S3标准S3 标准-IA不频，但能快速访问访问要钱用例：长期存储，备份，DR灾备99.9 Avail （少个9）11个9的持久性S3 One Zone-Infrequent Access类似于S3 Standard-IA只存在于单个AZ节约20%成本适合于不重要的长期存在数据99.5% Avil11个9的持久S3 Intelligent-Tiering使用AI决定去99.99% Avail11个9的持久性3 Glacier：Glacier Instant Retrieval 长期存储，立即获取Glacier Flexible Retrieval 理想的长期春初，需要几分钟到12小时来获取Glacier Deep Arcihive 7-10年的存储目标，12到48 小时获取99.99 A11个9持久 Lifecycle Management with S3生命周期管理30天转移在 S3 Glacier 中，您必须将数据存储在存档中，存档的最低时间限制为90天。这意味着，一旦您将数据存储在 S3 Glacier 中，您必须等待至少90天，才能检索该数据。这是因为 S3 Glacier 是一种适用于长期存储和归档的服务，而不是适用于频繁访问的热存储服务。 S3生命周期考点：自动在不同分类中移动和version一起用当前和过去version都可以 S3 Object Lock and Glacier Vault LockS3对象锁WORM 写一次，读很多次write once, read many用于监管需求Governance Mode治理模式无权限情况下， 不能删除或者覆盖Compliance Mode合规模式被保护对象无法被覆盖或者删除，任何用户都不行。包括Root用户也不行Retention Periods保留期在特定时间段内保留对象，逾期后可以覆盖和修改。除非加上了Legal Hold，加上了不能改Legal Hold是指一种法律程序，用于保护企业在诉讼或调查期间的电子数据。它是指企业在知道或合理预料到将要发生法律诉讼或调查时，采取的一系列措施，以确保与该诉讼或调查相关的信息不会被更改、删除或丢失。这些措施包括暂停数据销毁、备份和保留相关数据，并采取其他必要措施以确保数据完整性和可用性。 Legal Hold通常是由企业的法律部门或合规部门发起并监督的。如果企业没有及时采取Legal Hold措施，可能会面临法律责任和罚款。 Retention Mode：Retention Mode是一种数据保留模式，可确保对象在指定的保留期内不被删除或更改。在Retention Mode下，对象被锁定，无法被更改或删除。Retention Mode有两种模式：COMPLIANCE和GOVERNANCE。COMPLIANCE模式是一种严格的保留模式，保留期内的对象无法被删除或更改。GOVERNANCE模式是一种灵活的保留模式，允许管理员在保留期内删除和更改对象，但需要提前30天发出通知。3个 Object Lock的提示：1 S3 OL用来存放WORM模型2 OL可以是在单个对象，也可以在整个bucket上3 OL有两个模式：Gov Mode和Comp ModeLegal Hold Mode：Legal Hold Mode是一种法律保留模式，可确保对象在法律程序期间不被删除或更改。在Legal Hold Mode下，对象被锁定，无法被更改或删除，直到Legal Hold被解除。S3 OL Mode分类：Comp M：谁都不能改Gov M：特定人能改WORM模型是一种数据存储模型，即“Write Once Read Many”（只写一次，多次读取）。WORM模型的基本思想是，一旦数据被写入存储系统，就无法更改或删除，只能被多次读取。这种模型通常用于需要长期保留数据的场景，如合规性要求、法律诉讼、归档等。 WORM模型通常用于磁带库、光盘存储、硬盘阵列等存储系统中。在这些存储系统中，数据被写入后，存储系统会对其进行保护，以防止数据被意外或恶意删除或修改。这种保护通常包括数据备份、数据加密、访问控制等措施。 WORM模型的优点在于，它可以确保数据的完整性和可用性，防止数据被意外或恶意删除或修改。这对于需要长期保留数据的场景非常重要，如金融、医疗、法律等行业。同时，WORM模型也有一定的缺点，如存储成本高、数据访问速度较慢等。因此，在选择存储系统时，需要根据实际需求进行选择。这句话的意思是，AWS S3 Glacier Vault Lock功能允许您为每个S3 Glacier Vault轻松部署和执行合规性控制，并使用保管库锁定策略来保护其数据。Vault Lock是一种控制访问和保护数据的功能，它可以通过Vault Lock策略来限制对Vault的访问和修改。Vault Lock策略是一种JSON文档，可以定义保管库的访问权限、保留期限、删除保护等规则。 使用Vault Lock功能，您可以确保保管库中的数据符合合规性要求，并且不能被意外或恶意删除或修改。Vault Lock策略可以防止管理员或其他用户删除或修改数据，即使他们拥有相应的权限。Vault Lock还可以防止数据被意外或恶意删除或修改，从而保护数据的完整性和可用性。 总之，S3 Glacier Vault Lock功能提供了一种简单而有效的方式来确保S3 Glacier Vault中的数据符合合规性要求，并保护数据的完整性和可用性。在AWS S3 Glacier中，Vault指的是一种逻辑容器，用于存储数据归档。Vault是S3 Glacier中的基本存储单元，您可以将数据归档到Vault中，然后对其进行管理和检索。Vault可以看作是一个文件夹，您可以在其中创建和管理归档文件。 每个Vault都有一个唯一的名称，并且可以配置一些属性，如访问权限、保留期限、删除保护等。Vault中的归档文件可以通过AWS控制台、AWS CLI或AWS SDK进行管理和检索。您可以上传和下载归档文件，列出Vault中的所有归档文件，以及删除归档文件等。 在S3 Glacier中，Vault是一个重要的概念，它提供了一种方便而安全的方式来存储和管理数据归档。同时，Vault也是S3 Glacier中的一个重要的合规性要求，您需要确保Vault中的数据符合合规性要求，并保护数据的完整性和可用性。情境：WORM + S3: S3 Obj Lock -&gt; Comp, GovWORM + Glacier: Glacier Vault Lock Encrypting S3 ObjectsEncryption分类1 传输加密 SSL&#x2F;TLS HTTPS2 Rest加密：服务端加密 SSE-S3：S3-管理密钥，使用AES 256 SSE-KMS: AWS Key Mgmt Service SSE-C： Customer提供的key3 Rest加密 客户端加密上传之前加密，自己高两种强制执行桶加密的方式：Console 点击复选框就可以考点：BP 桶策略强制执行服务端加密：1:使用x-amz-server-side-encryption头2:两种选项：x-amz-server-side-encryption: AES256x-amz-server-side-encryption: aws:kms3:header放在PUT请求中，让S3加密obj，在上传的时候，使用指定的加密方法。可以创建BP，deny任何header不包含SSE头的PUT请求，考点：传输加密：SSL&#x2F;TLS，HTTPS服务端加密：SSE，SSE-S3， SSE-KM，SSE-C客户端加密：自定义强制加密：PUT请求 Optimizing S3 PerformanceS3性能优化 S3前缀越多，性能越高。第一个字节100-200ms 充不多5500个Get请求，per 桶，per 前缀（prefix）KMS限制：上传调用API下载调用APIKSM API调用配额分区域的，5500，10000， 30000每秒不能要求加量多段上传 推荐对&gt;100MB文件操作 大于5GB的必须分 并行传输 （下载：Byte-Range Fetches 并行下载，分byte段 失败只针对特定比特段S3 字节区域下载：加速下载可以只加载一部分文件（比如文件头）考点：1 Prefix指的是mybucketname&#x2F;sub1&#x2F;sub2&#x2F;file.jpg中&#x2F;sub1&#x2F;sub2&#x2F;这一段2 大量访问：3500 PUT&#x2F;COPY&#x2F;POST&#x2F;DELETE5500 GET&#x2F;HEADper second, per prefix3 分开prefix可以提高性能考点：KMS 有配额的 分区域，五千五，一万，三万请求每秒 不让加量考点：分段上传性能高100MB以上推荐，5GB必须分段S3 Byte-range fetch 可以加速下载 Backing up Data With S3 ReplicationS3 复制以前叫做跨区域复制3个考点：1 可以从一个桶复制到另一个桶2 现存的对象不会自动复制3 删除标记默认不会复制 S3 Exam Tips总结：基于对象、不适用OS、DB、之高5TB、容量无限全局名字，不可重名、上传成功返回2004点：key value verionId metadata安全4点：默认私有、对象ACLs、桶策略、HTTP代码成功200静态网站：桶策略、静态内容、自动扩容版本控制：全版本、备份、无法关闭、生命周期规则、支持MFA存储分级：S3 Std， S3 Std-IA， S3 OZ-IA，S3 Glacier， S3 Glacier DA，SA3 I-T重要数据：99.99，99.9， 99.5， 1生命周期：自动移动，联合版本使用，当前过去版本都可以使用S3对象锁：WORM模型，单个对象或者整个桶可以锁，分两类：Gov和CompGlacier锁：强制实施WORM加密：两类：传输加密SSL&#x2F;TLS，服务端加密：SSE（server-side enc）SSE-S3 （AES256） SSE-KMS SSE-C 客户端加密：自己解决 强制加密桶策略：加headerPrefix定义（文件夹名字） 性能 3500PUT，5500 GET、HEADER 越多Prefix，性能越高（2个能达到11000 GET）每秒KMS配额限定 5500，1万，3万，且无法增加性能优化：多部份上传，100MB以上，5GB以上必须，S3brf 快速下载 并列S3复制：以前叫跨区复制。也可以同区域复制，从一个buck到另一个buck，现存默认不复制，默认不复制删除标记 Elastic Compute Cloud (EC2)EC2 OverviewEC2计费标准：On-Demand 按需 按小时、秒Reserved 保留 1-3年Spot 竞价Dedicated 专用按需的场景：FlexShort termTest water保留实例场景：(RI)可预测的使用特定用量需求先付钱标准RI可转换RI调度RIRI能省钱至高72%需要承诺1-3年的用量超级flexible。不限定EC2， Lambda也ok何时使用Spot不能用来做网站。因为竞价，可能顶掉了。Flex yesUrgent noCost sensitive yesDedicated专用：合规性需求专用许可证AWS Price Calculator考点：EC2像个VM，在AWS而非自由数据中心。选择现在需要的容量按需缩放按用量付费等几分钟二不是几个月EC2付费选项： 按需，保留，Spot，专用。 Demo: Launching an EC2 Instance’ VPC是个虚拟dc一个subnet就是一个AZ AWS Command Lineaws s3 lsaws s3 mb s3:&#x2F;&#x2F;sdfdsfsdfsdfaws s3 cp hello.txt s3:&#x2F;&#x2F;sdfdsfsdfsdf 考点：给最少的权限；创建和使用IAM组，附加上IAM Policy，自动继承考点CLI：1 Secret Access Key 私密访问密钥 只能看一次2 不要分享 Key pair3 支持Win Linux和Mac Using Roles可以给EC2设置IAM Role成为S3 Admin考点：1 倾向使用Role2 避免硬编码角色3 政策是控制role的权限的4 可以直接更新policy5 可以attach和detah role给running EC2考点：1 用Role的确是最佳实践2 用Role可以通过ssh 附加.pem公钥登录了，因此不需要使用access key ID和secret access key了。3 策略。通过策略（Policies）来控制Role的权限4 更新。更新Role上附加的策略可以即刻生效5 附加，去除。可以随意的在运行中的EC2上附加或者去除Role。很方便 Security Groups and Bootstrap Scripts安全组和Bootstrip script计算机通信常用端口22338980443Bootstrap 脚本是初始化EC2时候运行的脚本。懂了安全组考点：0 安全组是虚拟的防火墙的概念1 安全组的更改会立即生效2 一个安全组内可以有任何数量的EC23 一个EC2也 可以附加上多个安全组4 默认禁止所有入境流量5 所有出境流量都是允许的 EC2 Metadata and User Datametadata指的是 关于EC2本身的一些数据https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html考点：1 User data 就是bootstrap script2 Metadata就是EC2数据3 能用bootstrap 脚本访问metadata Networking with EC2使用增强网络的时候，ENA100GB，VI10GB，选ENA 弹性构造适配器Elastic Fabric AdapterEFA：提速，降低延迟使用EFA，高性能计算HPC可以直接与机器学习程序通信，通过on-bypass.考点3中网络，ENI，低成本EN 10 ~100 GB的网速需求EFA 高性能计算场景，需要OS-bypass的场景。 Optimizing with EC2 Placement GroupsPlacement Group优化EC2集群 – 将一个可用区中靠近的实例打包在一起。通过使用该策略，工作负载可以实现所需的低延迟网络性能，以满足高性能计算（HPC）应用程序通常使用的紧密耦合的节点到节点通信的要求。 分区 – 将实例分布在不同的逻辑分区上，以便一个分区中的实例组不会与不同分区中的实例组使用相同的基础硬件。该策略通常为大型分布式和重复的工作负载所使用，例如，Hadoop、Cassandra 和 Kafka。 分布 – 将一小组实例严格放置在不同的基础硬件上以减少相关的故障。https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/placement-groups.html考点：1 cluster 集群 用于放在一起，减少延迟，提高吞吐量2 spread 分布，一个是一个3 partition 分区，几个是一个考点：集群不能跨az，其他两个可以只有特定的类型才能放在“置放群组”里，包括计算优化，内存优化，GPU，以及存储优化。AWS推荐一个集群里使用同质实例无法合并两个PG可以把现存实例移到PG里。（必须是关闭状态，而且只能通过AWS CLI或者SDK来实现，通过网页控制台目前还不可以） Solving Licensing Issues with Dedicated Hosts专用实例的场景：有许可证的情况 Timing Workloads with Spot Instances and Spot FleetsSpot得先给出你能给的最高价格。Spot考点：1 至高节省90%2 仅适用于不需要持久化存储的场景3 可以设置“不让停”时长4 Spot舰队Fleet是一些Spot和（可选）按需实例的结合 Deploying vCenter in AWS with VMware Cloud on AWSAWS上用VMware的几个场景考点：可以使用VMware去部署vCenter在AWS里 Extending AWS Beyond the Cloud with AWS OutpostsOutposts是把AWS服务带到本地的私有服务器上AWS Outposts Rack是一个完整的机架式设备，其中包含了计算、存储和网络设备，以及AWS云中的所有服务。AWS Outposts Server是一种单独的计算设备，它可以与现有的本地存储和网络设备配合使用。Rack和Server的区别要我说，就Rack什么都带，Server就单独一个Server；Rack U很多（40多），Server少（可能就一个）考点：AWS本地化，考虑Outpost大Rack小Server","tags":[{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"},{"name":"AWS","slug":"AWS","permalink":"https://xqtony.github.io/tags/AWS/"},{"name":"Cloud","slug":"Cloud","permalink":"https://xqtony.github.io/tags/Cloud/"},{"name":"云技术","slug":"云技术","permalink":"https://xqtony.github.io/tags/%E4%BA%91%E6%8A%80%E6%9C%AF/"}]},{"title":"AWS Certified Solution Architect Associate SAA-C03 笔记 (二)","date":"2023-06-26T16:02:34.650Z","path":"2023/06/27/AWS Certified Solution Architect Associate SAA-C03 part2/","text":"本篇是AWS Certified Solution Architect Associate SAA-C03 笔记的第二部分，涵盖了EBS，DB，Route 53及ELB的内容。 持续更新中… Elastic Block Storage (EBS) and Elastic File System (EFS)EBS Overview减轻记忆负载：仅在IOPS大于16000时，考虑io1或者io2 （Provisioned IOPS）io2有99.999的持久性 大数据，数据仓库，ETL，考虑st1最便宜 sc1 Volumes and SnapshotsEBS 弹性块存储，考点：1 Volume 虚拟磁盘存在于EBS中，snapshot在S3中2 snapshot是某一时刻对存储容器的照片，且具有增量的特定3 第一个snapshot得花点时间创建，为了创建一致的快照，需要停止实例，并解除容器的关联。4 可以在不同的region之间共享snapshot5 可以在使用EBS的过程中更换EBS容量类型 EBS（Elastic Block Store）是AWS提供的一种云存储服务，用于提供持久化的块存储。在EBS中，Volume和Snapshot是两个重要的概念。 Volume是EBS中的虚拟磁盘，它可以被挂载到EC2实例上，作为持久化的存储空间。Volume的大小可以根据需要动态调整，支持多种类型，如SSD和磁盘。Volume中存储的数据是持久化的，即使EC2实例被关闭或删除，数据仍然会保留在Volume中。 Snapshot是EBS中的备份机制，它可以对一个Volume进行快照备份，保存在S3中。Snapshot是一个只读的镜像，可以用来恢复Volume的数据，也可以作为新的Volume的基础镜像。通过定期创建Snapshot，可以保证数据的安全和可靠性，同时也可以提高恢复速度和灵活性。 总的来说，Volume是EBS中的存储空间，而Snapshot是对Volume的备份，用于数据的恢复和复制。两者共同构成了EBS的核心功能，为云应用提供了可靠的持久化存储服务。 Protecting EBS Volumes with Encryption加密的虚拟磁盘的考点：静态数据在磁盘内是加密的实例与磁盘之间的动态数据也是加密的镜像是加密的由镜像创建的虚拟磁盘也是加密的如何加密虚拟磁盘（考点）：创建一个未加密的根设备磁盘镜像复制一份镜像，过程中选择加密选项从加密镜像创建一个AMI用AMI启动新的加密实例 EC2 HibernationEC2休眠（考点）EC2休眠功能是让RAM里数据存到磁盘更快的启动速度因为不需要重启OS实例的RAM必须小于150GB实例家族包括C，M和R的3，4，5.支持Win，Amazon Linux 2 AMI，Ubuntu实例不能休眠超过60天休眠功能支持按需实例和保留实例 EFS Overview EFS简单来说就网络磁盘，NFS简单总结一下EFSNFSv4协议目前只支持Linux使用KMS加密自增的文件系统，不需要提前计划容量按用量收费. 1000+链接10GB每秒1000TB最多EFS支持存储分级，Standard收费高，IA收费低。可以指定生命周期，移动文件来省钱EFS考点：支持NFSv4按照用量付费支持PB级别存储千级并发NFS支持跨AZ存储具备读写一致性提示：看见NFS高扩展性共享存储就考虑EFS。 FSx Overview考点：看见SharePoint迁移，立马想到FSx for Windows。因为是使用了Windows一模一样的文件系统。考点：分布式，高弹性：EFSWindows相关： FSx for WinAI&#x2F;ML：FSx for Lustre Amazon Machine Images: EBS vs. Instance Store考点：分布式，高弹性：EFSWindows相关： FSx for WinAI&#x2F;ML：FSx for lustreAMI 亚马逊机器镜像 AMI就两种：来自其他EBS快照的EBS来自S3中存的模板的Instance storeinstance store volumes实例存储虚拟磁盘也叫 临时存储无法停止；重启不丢数据；删除实例则丢失实例存储虚拟磁盘。AWS中的Instance store volume是一种暂时性的存储设备，通常与EC2实例一起使用。它是通过直接连接到物理主机而不是网络来提供高性能和低延迟的存储。Instance store volume通常用于需要高性能和低延迟的应用程序，如数据库、缓存和日志文件。 Instance store volume有以下特点： 速度快：Instance store volume是直接连接到物理主机的，因此具有非常快的IO性能。 暂时性：Instance store volume的数据是暂时性的，如果实例终止或失败，数据将被删除。因此，Instance store volume不适合存储需要长期保存的数据。 可用性有限：Instance store volume的可用性取决于实例类型和区域。某些实例类型可能没有Instance store volume，而某些区域可能没有可用的Instance store volume。 因此，如果您需要高性能和低延迟的存储，而且数据不需要长期保存，那么Instance store volume是一个很好的选择。但是，如果您需要长期保存数据或需要高可用性和可靠性，那么建议使用EBS卷。考点：Instance store也叫临时存储 ephemeralInstance store不允许stopEBS可以stop这俩都可以重启，不丢数据默认这俩终止都删磁盘，但是EBS可以选择不删附加：AMI简单来说就是蓝图 AWS Backup考点：AWS备份，看到集中式管理所有服务类似需求考虑AWS备份。可以结合AWS Organization来实现多个账户的集中式管理好处是：集中管理；生命周期自定义；合规性的便利，可以强制备份生命周期，可加密，可审计。 EBS Exam TipsEBS总结考点：EBS固态：gp2启动盘，一万六，三九gp3高性能，也是三九，是gp2四倍性能io1也是三九，比前俩更快io2最快了，五九考点：EBS机械硬盘：st1 三九，不能当启动盘，用来当数据仓库，大数据的。sc1也是三九，便宜，不能当启动盘，用来放点不常用数据的，比如log什么的考点：比较Volume和Snapshot存储地点不同：EBS和S3快照是增量的，是虚拟磁盘某时刻的状态第一个快照花的时间会比较久。快照想要一致的话，要关机，解绑虚拟磁盘快照可以跨账户，跨区域共享，但是必须要先拷贝到目的区域EBS可以在运行中更改虚拟磁盘大小和类型考点：AMI的类型：EBS与Instace Store都能重启不丢东西EBS能stop，IS不能EBS能保留终止后的磁盘，IS不能IS是基于内存的。AMI就是蓝图加密卷考点：静态数据是加密的动态数据也是加密的快照是加密的所有加密快照创建的虚拟磁盘也是加密的加密流程重要考点：四步加密一个磁盘：1 创建一个快照2 复制快照，勾选加密选项3 基于加密快照创建AMI4 基于加密AMI启动加密实例休眠考点：休眠是把RAM存到EBS里了启动速度快RAM不能超过150GB支持的实例类型：C&#x2F;M&#x2F;R 3-5跨平台，Win，A L 2， Ubuntu休眠不能超过60天仅在按需和预留实例中有EFS考点：支持版本NFSv4千级并发按用量付费分布在同区域的多个AZ上最多PB级别读写一致重要：场景题目，提到高扩展性共享NFS，考虑EFS。考题：EFS：高并发FSx Win：微软专用FSx Lustre：AI&#x2F;ML考题：选啥存储实例S3：无服务存储冰川：归档EFS：跨AZ集中式存储FSx Lustre：AI&#x2F;ML等EBS Volume：持久性EC2用的硬盘Instance Store：临时性存一下EC2实例FSx for Win：微软全家桶考点：AWS备份：合并几乎所有服务结合AWS组织可以跨账户备份好处是：集中管理，自动备份，可以定义生命周期；合规性能力提高，可以强制备份，备份加密，可以备份完之后审计 DatabasesRelational Database Service (RDS) OverviewOLTP与OLAP的区别：T主打传输A主打分析RDS只能用来OLTP想要OLAP，记得Redshift（红移）RDS里的Multi-AZ ：就是个一模一样的备份。只能用作备份，不能用于负载均衡。Multi-AZ的备份能力由AWS提供，用户不关心备份的细节 考点：RDS类型有SQL Server，MySQL， PostgreSQL，MariaDB，以及Amazon AuroraRDS是为OLTP负载准备的RDS不适合OLAP负载 Increasing Read Performance with Read Replicas考点：Multi-AZ vs Read Replica 一模一样的备份，存放在其他AZ 只能用于容灾 灾难发生，RDS可以自动使用待机版本恢复 只读备份，可以是同AZ，跨AZ甚至跨Region 用来增加读性能（重点） 适用于heavy read的应用；也适用与隔离生产数据库，用于只读目的 What Is Amazon Aurora?Aurora考点：最少3个AZ，每个AZ有2个备份，最低6份数据Aurora镜像可以在账户之间共享3种Read 副本，Aurora，MySQL以及PostgreSQL，其中只有Aurora的具有自动failover能力Aurora默认开启自动备份，也可以手动创建镜像。Aurora无服务简单便宜，不可预测的负载情境下适用 DynamoDB OverviewDynamoDB考点：4个事实：存储在SSD上分布在3个不同地理位置的DC支持 最终一致性读取 和 强一致性读取最终一致性读取： 最佳读取性能，一秒钟内所有数据的备份都是一致的强一致性读取：任意时刻读取的内容都包含改时刻之前的所有写入操作。 When Do We Use DynamoDB Transactions?DynamoDB Transactions考点：场景题：任何提及ACID需求的DynamoDB提速原子性，一致性，隔离性，持久性在一个或多个表的一个AWS账户和一个区域内全部或没有 Saving Your Data with DynamoDB BackupsDynamoDB中的备份Point-in-Time Recovery的特点：保护意料之外的写操作或删除操作可以回退到35天内任何时间递增的备份默认不开启最新的回退的是5分钟之前。5分钟之内不能。 Virtual Private Cloud (VPC) NetworkingVPC OverviewVPC中包含Web，Application，Database三种子网。Web是公共子网，面向互联网Application是私有子网，面向web tier和db tierDatabase也是私有子网，只面向app tier。可以在公司数据中心和AWS云之间建立VPN一个计算IP地址段的网站AWS里是最多能支持10.0.0.0&#x2F;16，保留了一部分地址。局域网地址有三个网段：（复习）10.0.0.0&#x2F;8172.16.0.0&#x2F;12192.168.0.0&#x2F;16 很多组织，公司 ，都用10.0.0.0下面两节的架构Internet Gateway网关Virtual Private Gateway 虚拟私有网关默认VPC vs 自定义VPC：默认VPC更简单，默认VPC子网都有连接到Internet的路由，每个EC2实例都有一个公共和私有IP。自定义VPC可以完全自定义，但是要花时间去配置。 Demo: Provisioning a VPC - Part 1Classless Inter-Domain Routing (CIDR) is an IP address allocation method that improves data routing efficiency on the internet.subnet约等于虚拟防火墙 VPC设置IP地址的时候，会保留5个地址。0 网络地址1 VPC路由2 DNS服务器3 保留255 广播地址，VPC没有广播但是保留VPC考点：VPC可以认为是AWS中的逻辑数据中心VPC包含网关（或者叫虚拟私有网关），路由表，网络访问控制列表，子网，以及安全组一个子网只存在于一个AZ里 （常考）。 Demo: Provisioning a VPC - Part 2ICMP是ping相关的配置公共子网，通过公共子网里的机器ssh到私有子网的机器上，yum update一下发现的确不能访问互联网。 Using NAT Gateways for Internet AccessNAT Gateway的5个要点：1 在AZ里冗余2 5Gbps起步，目前最高45Gbps3 无需patch4 与安全组无关联5 自动分配公有IP地址 Protecting Your Resources with Security Groups这一节复习安全组，主要强调安全组是有状态的。有状态是指当你在实例上发送一个请求，它的response是可以无视inbound安全组规则的。同理，一个inbound请求进来之后的响应可以无视outbound规则外流。安全组的是有状态的。它能记得住一个入站请求，并在出站的时候自动放行，而无视出站规则。 Controlling Subnet Traffic with Network ACLsNetwork ACL:1 可选的配置，和防火墙很像，可以控制in、out的流量，可以在一个或多个子网上生效2 可以配置与安全组类似的配置，来额外添加一层防护。补充：默认网络ACL：VPC自动创建的，默认允许所有流入流出的流量自定义网络ACL：可以创建自定义的 ACL。默认的自定义ACL禁用所有的流入流出流量（重点）子网关联：每个子网必须与一个ACL关联。如果不显式的指定子网关联，则自动的与默认ACL关联。IP拦截：拦截IP使用的是ACL，而不是安全组。ACL与子网：ACL与子网是一对多的关系；一个ACL可以关联多个子网，但是一个子网一次只能关联一个ACL。当一个子网与新的ACL关联，其旧的ACL关联会被移除掉。 ACL中的rule，需要越小的越先执行。ACL把入站和出站规则分开了，每个rule可以是白名单或黑名单。ACL是无状态的。入站允许的相应也需要服从出站的规则。反之亦然。Ephemeral ports 译作临时端口，是创建TCP链接时候会用到的端口。刚才的例子里，为出站规则开放了TCP的一系列临时端口。考点： 默认ACL允许所有入站和出站流量 自定义的ACL默认Deny所有流量 子网关联：子网必须与某个ACL关联，如果不指定，默认关联到默认ACL上。 IP拦截：只能通过ACL实现IP拦截。安全组做不到IP拦截。 ACL与安全组是一对多的关系。给安全组执行新ACL会替换掉原来的ACL。 ACL包含一系列rule，按照序号从小到大执行。 ACL分为入站和出站两套规则，每套里面又分为允许和拒绝两种。 ACL是无状态的。它记不住曾经放行过的规则，所以入站出站都得配置一次。 Private Communication Using VPC EndpointsAWS中的VPC Endpoint是什么？如何理解它？它有什么用？ AWS中的VPC Endpoint是一种连接VPC与AWS服务的方式，使得您的VPC内的资源可以私有地访问AWS服务，同时不需要通过Internet Gateway或NAT设备。 VPC Endpoint可以理解为一个虚拟的网络设备，它提供了一个接口，使得您的VPC内的资源可以直接与AWS服务通信，而无需通过Internet连接。这意味着您可以更加安全地连接到AWS服务，并且不需要在VPC和AWS服务之间暴露任何公共IP地址。 VPC Endpoint可以用于连接多种AWS服务，例如S3、DynamoDB、Kinesis等。使用VPC Endpoint可以提高安全性、可靠性和性能，并且可以减少网络数据传输的成本。什么东西在VPC内？什么AWS服务在VPC之外？ 在VPC内可以包含各种AWS资源，例如EC2实例、RDS数据库、Elasticache缓存、Lambda函数等。此外，您还可以在VPC内创建各种网络资源，例如子网、路由表、网络ACL等。通过将这些资源放置在VPC内，您可以更好地控制它们的安全性和网络连接。 AWS服务可以分为两类：一类是可以在VPC内使用的服务，例如S3、DynamoDB、Kinesis等；另一类是无法在VPC内使用的服务，例如Route 53、CloudFront等。对于无法在VPC内使用的服务，您需要通过Internet连接来访问它们。但是，AWS提供了一些安全性更高的连接方式，例如VPC Endpoint和VPN连接，使得您可以更加安全地连接到这些服务。AWS中需要通过Interface Endpoint连接的服务包括： Elastic Compute Cloud (EC2)Relational Database Service (RDS)Elastic CacheElastic Kubernetes Service (EKS)DocumentDBAWS PrivateLink这些服务需要通过Interface Endpoint连接，因为它们是在VPC中运行的服务，需要使用私有IP地址进行通信。AWS中需要通过Gateway Endpoint连接的服务包括： Simple Storage Service (S3)DynamoDB这些服务需要通过Gateway Endpoint连接，因为它们是在AWS公共基础设施上运行的服务，无法直接使用私有IP地址进行通信。AWS提供了两种类型的VPC Endpoint：Gateway类型和Interface类型。 Gateway类型的VPC Endpoint用于连接S3和DynamoDB这样的AWS服务。它们是通过VPC Endpoint连接到AWS服务的，但是在VPC Endpoint内部使用的是AWS公共IP地址。这种类型的VPC Endpoint可以用于连接多个AWS服务，但是不能用于连接在VPC中运行的服务。 Interface类型的VPC Endpoint用于连接在VPC中运行的服务，例如EC2、RDS和Elasticache等。它们使用了一个私有IP地址，可以直接将流量路由到VPC中的资源。这种类型的VPC Endpoint可以用于连接多种AWS服务，但是需要在每个服务上创建一个独立的VPC Endpoint。 因此，Gateway类型的VPC Endpoint适用于连接AWS服务，而Interface类型的VPC Endpoint适用于连接在VPC中运行的资源。通过VPC Endpoint连接S3，而不是通过NAT连接S3.这里VPC Endpoint的类型是GatewayVPC EP考点： 想纯通过AWS内网连接AWS服务的时候使用 两种类型，接口和网关 网关类型支持S3和DynamoDB，仅此两种。 Building Solutions across VPCs with Peering多VPCs的互联问题：VPC Peering：允许使用私有IP地址将VPC互联实例的行为会像他们在同一子网一样甚至可以跨账户将VPC互联星型配置。不可传递。可以跨区域Region互联如图，必须建立直连，不能传递。VPC Peering 考点：1 允许使用private IP把VPC互联2 传递互联不支持，不行3 可以跨区域互联4 CIDR 地址不能重叠（合理，毕竟可以私有IP通信） Network Privacy with AWS PrivateLinkPrivateLink考点：当有Peering VPC到数十个，上百个甚至上千个用户VPC的时候，考虑PrivateLink。PrivateLink不需要VPC Peering，不需要路由表，不需要NAT网关，不需要互联网网关等等。需要服务端VPC开启网络负载均衡器，需要客户端开启ENI弹性网络接口。它区别与VPC Peering，它不会暴露整个VPC里的所有服务，应该是只会暴露需要的服务。与互联网开放的区别是更安全，更好管理。 Securing Your Network with VPN CloudHubAWS VPN CloudHub如果有多个网站，每个网站有自己的VPN连接，可以使用AWS VPN CloudHub把这些site连接到一起。类似于VPC Peering，工作模式成为hub and spoke模型。它低费率，易管理。尽管是在互联网上操作的，但是全程加密。考试看到多个VPN相关的，考虑这个。 Connecting on Premise with Direct ConnectVPN vs Direct Connect：VPC也是私密通信。但是VPC traverse（遍历，横过）公网。VPC安全但是也很痛苦。Direct Connect相比之下更加：快，安全，可靠，可以支持很大很大的吞吐量Direct Connect 考点：把公司数据中心和AWS直接连接起来很有用在高throughput workload的情况想建立稳定可靠的安全传输，选它 Simplifying Networks with Transit GatewayTransit Gateway考点：类似于VPC Peering，也是hub and spoke（辐）结构它作为一个中心，可以简化VPC之间连接的拓扑结构支持Direct Connect和VPNAWS服务中唯一支持多播的服务可以使用路由表来控制VPC之间的路由关系 5G Networking with AWS WavelengthAWS Wavelength:暂时还没出现在考试中。如过看到5G，超低延迟，边缘计算等字样，考虑AWS Wavelength VPC Networking Exam Tips考点：高可用NAT当资源分布在多个AZ中时，NAT Gateway所在AZ如果down了，那其他AZ中的资源就无法访问网络了。解决方案是在每个AZ中配置NAT Gateway，保证每个AZ中的资源使用同一个AZ中的NAT Gateway。考点：安全组是stateful的。让进则让出，无视出站；反之亦然。考点：IP黑名单通过Network ACL实现考点：VPC Endpoint保证你在AWS内部将服务互联。分为Interface和Gateway，其中Gateway只支持S3和DynamoDB这两个，原因是他俩是公网IP地址。Interface支持其他使用私有IP地服务。考点：PrivateLink是用来peering成百上千VPC的。它不需要VPC Peering&#x2F;Route Table&#x2F;NAT Gateway&#x2F;Internet Gateway，都不要。它只要服务端的Network 负载均衡，以及客户端的ENI 弹性网络接口。考点：Transit Gateway。它是星型结构，用来把VPC，Direct Connect还有VPN都连接到一个点上，方便管理。支持多播。考点：VPN Hub，集中式管理所有VPN连接，方便VPN连接之间互联。 Route 53Route 53 OverviewDNS是什么？IPv4 vs IPv6顶级域名域名注册商常用DNS记录类型TTL是什么？别名记录路由策略考点DNS是什么呢？DNA就是把人类友好的字符串域名映射到IP地址的服务。Top-Level Domain顶级域名，指的是域名最后一个单词，像是com，cn，edu等等。5个常用的域名注册商domain.comGoDaddyHooverAWSNamecheapNS记录，Name Server记录，是当域名需要使用自己的DNS服务器来解析的时候，可以使用NS记录，将该域名指向自己的服务器。图中示例，域名-顶级域名-NS记录-SOA A记录:域名翻译成IP地址TTL:Time to live. TTL越短,DNS刷新的就越频繁.Canonical是一个词汇，可以用作形容词或名词。作为形容词，它表示“标准的”、“典范的”或“正式的”，通常用于描述某个特定领域中的标准或规范。作为名词，Canonical通常指代Linux发行版Ubuntu的公司Canonical Ltd。 例如，我们可以说：“这个网站提供了一个Canonical的定义”，这意味着这个网站提供了一个关于某个领域中的标准或规范的定义。又如：“Canonical公司是Ubuntu的开发商”，这意味着Canonical是Ubuntu的背后公司。CNAMECanonical Name标准、典范名称CNAME是用来从一个域名映射到另一个域名的。Alias Record是AWS Route 53服务中的一种记录类型，因此它是AWS特有的。与CNAME的区别在于Alias Records不走公网，所以对于AWS服务来说性能更好，更可靠。而且Alias可以映射ip和域名，相当于结合了A记录和CNAME。 Demo: Using a Simple Routing PolicySimple Routing Policy，配置多个IP则随机分配 Demo: Using a Weighted Routing Policy考点：权重路由策略，可以设置权重health check，可以检查每个记录的健康状态，如果fail则临时移除。可以设置SNS服务来提示fail的情况。 Demo: Using a Failover Routing Policy在AWS EC2中的WebDMZ中，DMZ通常指的是Demilitarized Zone，即非军事区，是一种网络安全架构设计模式，用于在互联网和内部网络之间创建一道安全屏障，以保护内部网络中的敏感资源不受外部网络的攻击或入侵。在WebDMZ中，DMZ通常用于部署Web服务器，以便在互联网上提供服务，同时保护内部网络中的其他资源。考点：Failover Routing Policy：涉及到Active和Passive，考虑failover。 Demo: Using a Geolocation Routing Policy考点Geolocation Routing Policy：重点，当看到基于用户地理位置，考虑到本地化或者监管需求，但是与访问的延迟无关的情况，考虑这个。 Demo: Using a Geoproximity Routing Policy复杂，不常用的考点：Geoproximity Routing Policy基于用户位置和资源的地理位置。可以选择基于bias设置路由。必须基于Route 53 traffic flow来设置geoproximity routing。 Demo: Using a Latency Routing Policy考点：Latency Routing Policy基于延迟的路由策略。那就是哪儿延迟低就路由到哪里。 Demo: Using a Multivalue Answer Routing PolicyMultivalue Answer Routing多值路由本质上是Simple Routing Policy加上了HC。分开写。 Elastic Load Balancing (ELB)ELB OverviewELB概述3种LB：Application LBNetwork LBClassic LB Using Application Load BalancersApplicaton LB：包含以下内容：Listener：检查客户端请求状态Rules，rule包含优先级，一个及以上的action和conditionTarget Groups，路由的目标，每个TG要配置上HC；Limitations，只支持HTTP和HTTPSHTTPS Network LB：1 Layer42 机制性能3 ALB不支持的协议，来NLB4 NLB能解密流量，但是需要配置证书 Classic LB：504意味着超时，考虑DB或者实例。需要用户的IPv4地址的时候，可以使用X-Forwarded-For头粘性sessionSticky Session可以保证用户持续的访问同一台EC2实例。场景题目，当EC2实例down了，LB依然把流量转发到该EC2解决上面的问题考虑disable SS。 ALB也可以开启Sticky Session，但是只能是TG层面的。 Deregistration Delay注销延迟打开注销延迟：保持连接，当EC2不healthy关闭注销延迟：当你希望LB立即关闭连接到不健康实例，就关闭注销延迟。","tags":[{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"},{"name":"AWS","slug":"AWS","permalink":"https://xqtony.github.io/tags/AWS/"},{"name":"Cloud","slug":"Cloud","permalink":"https://xqtony.github.io/tags/Cloud/"},{"name":"云技术","slug":"云技术","permalink":"https://xqtony.github.io/tags/%E4%BA%91%E6%8A%80%E6%9C%AF/"}]},{"title":"Kafka初探","date":"2023-05-28T12:17:39.529Z","path":"2023/05/28/kafka/","text":"Kafka中哪些特性是基于Zookeeper开发的？哪些特性是独立的？ Kafka中基于Zookeeper开发的特性包括： Broker注册和发现：Kafka Broker在启动时会向Zookeeper注册自己的信息，并在需要时从Zookeeper获取其他Broker的信息。 Topic和Partition的管理：Kafka的Topic和Partition信息都存储在Zookeeper中，Kafka Broker在启动时会从Zookeeper获取Topic和Partition的信息。 Consumer Group的协调：Kafka Consumer Group的协调也是通过Zookeeper实现的，每个Consumer Group会在Zookeeper上创建一个节点，用于存储Group的信息和状态。 Leader选举：Kafka的Partition会被分配给多个Broker，其中一个Broker会被选举为Partition的Leader，Leader负责处理读写请求。当Leader宕机时，Kafka会通过Zookeeper进行Leader选举。 Kafka中独立的特性包括： Producer和Consumer的API：Kafka提供了Producer和Consumer的API，用于发送和接收消息。 消息存储：Kafka使用自己的存储引擎来存储消息，与Zookeeper无关。 消息复制：Kafka支持消息复制，当Broker宕机时，消息可以从备份的Broker中恢复。 消息压缩和批处理：Kafka支持对消息进行压缩和批处理，以提高传输效率。 参考链接： 什么是 Apache Kafka关于在 AWS 上运行 Apache Kafka 的最佳实践Kafka支持百万级TPS的秘密都藏在这里支持百万级TPS，Kafka是怎么做到的？答案藏在这10张图里图解 Kafka漫画：图解 Kafka，看本篇就足够啦超详细“零”基础kafka入门篇kafka是什么？APACHE KAFKAKafka宕机后不再高可用？探究Kafka高可用实现Kafka是什么？主要应用在什么场景?如何设计高可用？KafkaKafka 安装部署、集群启动、命令行操作 与 可视化工具 Kafka Tool","tags":[{"name":"二创","slug":"二创","permalink":"https://xqtony.github.io/tags/%E4%BA%8C%E5%88%9B/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"},{"name":"Kafka","slug":"Kafka","permalink":"https://xqtony.github.io/tags/Kafka/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://xqtony.github.io/tags/Zookeeper/"}]},{"title":"目标","date":"2023-05-28T03:17:48.590Z","path":"2023/05/28/todo/","text":"待办事项罗列出需要掌握的技术知识点。考虑在GitHub上上线项目来实践。 Java Java虚拟机原理 Java高级特性和类库 Java网络与服务器编程 Java多线程编程 JVM调优 NIO、RPC框架 AWS SAA-C03 DVA-C02 Golang Golang语言机制 开发工具的使用，定位和调试问题 分布式 理解什么是分布式架构，精通主流框架原理 Spring Cloud Dubbo Zookeeper 中间件 MySQL Redis HBase MongoDB Kafka ElasticSearch 前端技术 JS JQuery ReactJs Vue 网络编程 HTTP协议 缓存 序列化 RPC框架 容器 Docker K8s （含二次开发） Linux 编写脚本bash shell 熟悉环境 DevOps DevOps概念 CI&#x2F;CD pipelines 理论基础 计算机网络 数据结构 操作系统 算法 设计模式 软实力 技术钻研能力 分析问题解决问题 独立承担任务 系统进度把控 独立负责跨足项目 结果导向 代码风格及文档 良好的编码习惯 技术文档编写能力 英语书面交流 没来得及整理的内容https://www.cnblogs.com/kuanglongblogs/p/11230250.html 芋道源码 &#x2F; SpringBoot-Labsjava8 stream多字段排序国内顶级开源项目：芋道、ruoyi、JeecgBoot、pig、SpringBlade功能对比图解 Kafka漫画：图解 Kafka，看本篇就足够啦超详细“零”基础kafka入门篇kafka是什么？APACHE KAFKAKafka宕机后不再高可用？探究Kafka高可用实现Kafka是什么？主要应用在什么场景?如何设计高可用？","tags":[]},{"title":"简单记录下GitHub SSH访问的配置","date":"2023-05-28T03:17:48.590Z","path":"2023/05/28/ssh git config/","text":"最近发现http方式pull和push都很容易出现下面的log： 12C:\\Users\\xqkon\\Documents\\Work\\xqtony.github.io&gt;git pushfatal: unable to access &#x27;https://github.com/xqtony/xqtony.github.io.git/&#x27;: Failed to connect to github.com port 443 after 21068 ms: Timed out 找到的最可靠的方案是切换成SSH。 通过下面的命令生成公钥和私钥，邮箱记得替换成自己的。 1ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; 设置成功之后可以测试连通性： 1ssh -T git@github.com 添加一下ssh方式访问，但是因为已经存在一个origin了，只能叫origin_ssh了。 12git remote add origin_ssh git@github.com:xxxxxxxxxx.gitgit push -u origin_ssh master 最好把remote的名字也修改了。 1234567891011# list all remotesgit remote -vgit remote rename origin origin_httpgit remote -vgit remote rename origin_ssh origingit remote -v 新发现可以直接删除掉原来的remote: 1git remote rm origin 然后重新添加就可以了。 123git remote add origin git@github.com:xxxxxxxxxx.gitgit branch --set-upstream-to=origin/main maingit push -u origin main 参考资料： 最新解决git拉取远程仓库失败问题：Failed to connect to github.com port 443: Timed out.git使用——10.使用ssh方式推送git项目通过SSH向GitHub push代码git重命名远程名称","tags":[{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"git","slug":"git","permalink":"https://xqtony.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://xqtony.github.io/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"https://xqtony.github.io/tags/ssh/"}]},{"title":"区分几个reverse方法","date":"2023-05-25T23:24:08.374Z","path":"2023/05/26/reverses/","text":"下列的几个reverse你能分清楚吗？ 1234Comparator.reversed();Comparator.reverseOrder();Collections.reverse();Collections.reverseOrder(); 来看看源码： Comparator.reversed(): 12default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this); 返回一个比较器，强制该比较器的相反顺序。 Comparator.reverseOrder: 123public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() &#123; return Collections.reverseOrder();&#125; 返回一个与 自然排序相反的比较器。 Collections.reverse(): 1234567891011121314151617181920public static void reverse(List&lt;?&gt; list) &#123; int size = list.size(); if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--) swap(list, i, j); &#125; else &#123; ListIterator fwd = list.listIterator(); ListIterator rev = list.listIterator(size); for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) &#123; Object tmp = fwd.next(); fwd.set(rev.previous()); rev.set(tmp); &#125; &#125;&#125;private static void swap(List&lt;?&gt; list, int i, int j) &#123; final List l = list; l.set(i, l.set(j, l.get(i)));&#125; 此方法反转指定列表中元素的顺序。 Collections.reverseOrder(): 12345678910111213public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) &#123; if (cmp == null) &#123; return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER; &#125; else if (cmp == ReverseComparator.REVERSE_ORDER) &#123; return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE; &#125; else if (cmp == Comparators.NaturalOrderComparator.INSTANCE) &#123; return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER; &#125; else if (cmp instanceof ReverseComparator2) &#123; return ((ReverseComparator2&lt;T&gt;) cmp).cmp; &#125; else &#123; return new ReverseComparator2&lt;&gt;(cmp); &#125; &#125; 此方法返回一个比较器，它强制指定比较器的反向排序。当不指定比较器的时候，返回ReverseComparator.REVERSE_ORDER。那顺便看下ReverseComparator的实现： 12345678910111213141516171819private static class ReverseComparator implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable &#123; @java.io.Serial private static final long serialVersionUID = 7207038068494060240L; static final ReverseComparator REVERSE_ORDER = new ReverseComparator(); public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) &#123; return c2.compareTo(c1); &#125; @java.io.Serial private Object readResolve() &#123; return Collections.reverseOrder(); &#125; @Override public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123; return Comparator.naturalOrder(); &#125; 可见ReverseComparator.REVERSE_ORDER排序的顺序与自然排序刚好相反。 总结： Comparator.reversed(): 无参数。底层调用Collections.reverseOrder(this)。返回一个与调用者比较器相反顺序的新的比较器。 Comparator.reverseOrder(): 无参数。底层调用Collections.reverseOrder()。返回一个与自然排序相反的比较器。 Collections.reverse(): 接受一个List类型参数，反转该List。无返回值。 Collections.reverseOrder(): 无参调用时，返回一个与自然排序相反的比较器；有参调用时，返回与参数相反的比较器。 参考： Java Comparator使用指南 —- 看这一篇就够了Java 8 新特性】Java Comparator.reverseOrder | 倒序排序-静态方法深入学习java源码之Comparator.reverseOrder()与Comparator.compare ()Java.util.Collections 类","tags":[{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"},{"name":"Collections","slug":"Collections","permalink":"https://xqtony.github.io/tags/Collections/"},{"name":"Comparator","slug":"Comparator","permalink":"https://xqtony.github.io/tags/Comparator/"},{"name":"reverse","slug":"reverse","permalink":"https://xqtony.github.io/tags/reverse/"}]},{"title":"Lambda中比较器Comparator的使用","date":"2023-05-25T22:15:31.551Z","path":"2023/05/26/lambda in Comparator/","text":"如果你赶时间： 12list.sort((Developer o1, Developer o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); // 显式类型listDevs.sort((o1, o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); // 隐式类型，效果一致 一、概念先来看下典型的比较器示例： 123456Comparator&lt;Developer&gt; byName = new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getName().compareTo(o2.getName()); // name是String类型 &#125;&#125; Java8中引入了Lambda表达式，比较器可以改成下面这样： 1Comparator&lt;Developer&gt; byName = (Developer o1, Developer o2) -&gt; o1.getName().compareTo(o2.getName()); 对于数组，Arrays.sort()提供了传入比较器的重载方法，对于列表，Collections.sort()也提供了传入比较器的重载方法。 二、使用实例2.1 通过new 新建比较器假如我们要通过Developer 对象的年龄进行排序，通常情况下我们使用Collections.sort，new个匿名Comparator 类，类似下面这种： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.math.BigDecimal;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class TestSorting &#123; public static void main(String[] args) &#123; List&lt;Developer&gt; listDevs = getDevelopers(); System.out.println(&quot;Before Sort&quot;); for (Developer developer : listDevs) &#123; System.out.println(developer); &#125; //sort by age Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // return o1.getAge() - o2.getAge(); return Integer.compare(o1.getAge(), o2.getAge()); &#125; &#125;); System.out.println(&quot;After Sort&quot;); for (Developer developer : listDevs) &#123; System.out.println(developer); &#125; &#125; private static List&lt;Developer&gt; getDevelopers() &#123; List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;(); result.add(new Developer(&quot;ricky&quot;, new BigDecimal(&quot;70000&quot;), 33)); result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;), 20)); result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;), 10)); result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;), 55)); return result; &#125;&#125; 输出结果： 1234567891011Before SortDeveloper [name=ricky, salary=70000, age=33]Developer [name=alvin, salary=80000, age=20]Developer [name=jason, salary=100000, age=10]Developer [name=iris, salary=170000, age=55]After SortDeveloper [name=jason, salary=100000, age=10]Developer [name=alvin, salary=80000, age=20]Developer [name=ricky, salary=70000, age=33]Developer [name=iris, salary=170000, age=55] 当比较规则发生变化时，你需要再次new个匿名Comparator 类： 123456789101112131415161718192021222324252627//sort by ageCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // Tony updated: 尽管几乎不可能溢出，但存在这种可能性 // return o1.getAge() - o2.getAge(); // 参考这篇博客：https://xqtony.github.io/2023/05/26/compareTo/ // 应该使用下面的实现方法： return Integer.compare(o1.getAget(), o2.getAge()); &#125;&#125;);//sort by nameCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getName().compareTo(o2.getName()); &#125;&#125;);//sort by salaryCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getSalary().compareTo(o2.getSalary()); &#125;&#125;); 这样也可以，不过你会不会觉得这样有点怪，因为其实不同的只有一行代码而已，但是却需要重复写很多代码？ 2.2 通过Lambda表达式新建比较器在java8中，List接口直接提供了排序方法， 所以你不需要使用Collections.sort： 123456789101112//List.sort() since Java 8listDevs.sort(new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // Tony：原文中存在两个问题： // 1. 溢出风险 // 2. 顺序写反了 // return o2.getAge() - o1.getAge(); // Tony: return Integer.compare(o1.getAget(), o2.getAge()); &#125;&#125;); Lambda改写： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;public class TestSorting &#123; public static void main(String[] args) &#123; List&lt;Developer&gt; listDevs = getDevelopers(); System.out.println(&quot;Before Sort&quot;); for (Developer developer : listDevs) &#123; System.out.println(developer); &#125; System.out.println(&quot;After Sort&quot;); // Tony： 原文使用了下面的实现 // listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge()); listDevs.sort((Developer o1, Developer o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); //java 8 lambda feature listDevs.forEach((developer)-&gt;System.out.println(developer)); // Tony注： // listDevs.forEach(System.out::println); &#125; private static List&lt;Developer&gt; getDevelopers() &#123; List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;(); result.add(new Developer(&quot;ricky&quot;, new BigDecimal(&quot;70000&quot;), 33)); result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;), 20)); result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;), 10)); result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;), 55)); return result; &#125;&#125; 输出： 1234567891011Before SortDeveloper [name=ricky, salary=70000, age=33]Developer [name=alvin, salary=80000, age=20]Developer [name=jason, salary=100000, age=10]Developer [name=iris, salary=170000, age=55]After SortDeveloper [name=jason, salary=100000, age=10]Developer [name=alvin, salary=80000, age=20]Developer [name=ricky, salary=70000, age=33]Developer [name=iris, salary=170000, age=55] 2.3 更多的例子根据年龄： 123456789101112131415161718 //sort by ageCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; // return o1.getAge() - o2.getAge(); return Integer.compare(o1.getAget(), o2.getAge()); &#125;&#125;);//lambda// Tony 注：同样的问题// listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge());listDevs.sort((Developer o1, Developer o2) -&gt; Integer.compare(o1.getAge(), o2.getAge()));//lambda, valid, parameter type is optional// Tony 注：同样的问题// listDevs.sort((o1, o2)-&gt;o1.getAge()-o2.getAge());listDevs.sort((o1, o2) -&gt; Integer.compare(o1.getAge(), o2.getAge())); 根据名字： 12345678910111213//sort by nameCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getName().compareTo(o2.getName()); &#125;&#125;);//lambdalistDevs.sort((Developer o1, Developer o2)-&gt;o1.getName().compareTo(o2.getName()));//lambdalistDevs.sort((o1, o2)-&gt;o1.getName().compareTo(o2.getName())); 根据薪水： 1234567891011121314//sort by salaryCollections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123; @Override public int compare(Developer o1, Developer o2) &#123; return o1.getSalary().compareTo(o2.getSalary()); &#125;&#125;);//lambda// Tony注：使用compareTo()同样可以，本质上底层还是在调用compare()方法listDevs.sort((Developer o1, Developer o2)-&gt;o1.getSalary().compareTo(o2.getSalary()));//lambdalistDevs.sort((o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary())) 从小到大排序： 12Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary());listDevs.sort(salaryComparator); 从大到小倒序： 123456Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary());listDevs.sort(salaryComparator.reversed());// Tony 注：掘金版本给出了下面的实现：// Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o2.getSalary().compareTo(o1.getSalary());// 但是实际上根据Comparator接口中compare函数的定义，当o1的值小于o2，应该返回负值。因此上面这行的实现违反设计原则的，并不推荐。 本文虽然大部分是转载，但关于Integer类型的数值比较防止溢出问题，以及对compare()方法的设计均有重要注解，因此归类为二创。 参考：java8-Lambda中比较器Comparator的使用 - CSDNjava8-Lambda中比较器Comparator的使用 - 掘金Java8 Lambda表达式（二）System.out::println与Lambda表达式","tags":[{"name":"compare","slug":"compare","permalink":"https://xqtony.github.io/tags/compare/"},{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"二创","slug":"二创","permalink":"https://xqtony.github.io/tags/%E4%BA%8C%E5%88%9B/"},{"name":"Comparator","slug":"Comparator","permalink":"https://xqtony.github.io/tags/Comparator/"},{"name":"Lambda","slug":"Lambda","permalink":"https://xqtony.github.io/tags/Lambda/"}]},{"title":"比较Collections.sort()与Arrays.sort()","date":"2023-05-25T22:04:40.531Z","path":"2023/05/26/two sort/","text":"Collections.sort() 与 Arrays.sort() 的异同？Collections.sort() 和 Arrays.sort() 都是 Java 中用于排序的方法，它们的异同如下： 参数类型不同：Collections.sort() 方法接受 List 类型的参数，而 Arrays.sort() 方法接受数组类型的参数。 底层实现不同：Collections.sort() 方法使用的是归并排序（Merge Sort）算法，而 Arrays.sort() 方法使用的是快速排序（Quick Sort）算法。 排序稳定性不同：Collections.sort() 方法是稳定排序，即对于相等的元素，排序前后它们的相对位置不会发生改变。而 Arrays.sort() 方法是不稳定排序，即对于相等的元素，排序前后它们的相对位置可能会发生改变。 性能表现不同：Arrays.sort() 方法在大多数情况下比 Collections.sort() 方法性能更好，因为它对原始数据进行排序，不需要进行额外的包装和拆包操作。 综上所述，如果需要对 List 进行排序，应该使用 Collections.sort() 方法；而如果需要对数组进行排序，应该使用 Arrays.sort() 方法。 但需要注意的是，Arrays.sort() 方法和Collections.sort() 方法在排序时都可能会改变原始对象内元素的顺序，所以在使用前需要备份。 另外注意，使用Collections.sort()时，被排序列表中的元素必须实现Comparable接口中的compareTo方法。 参考：Java中Collections.sort()的使用!","tags":[{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"Collections","slug":"Collections","permalink":"https://xqtony.github.io/tags/Collections/"},{"name":"Arrays","slug":"Arrays","permalink":"https://xqtony.github.io/tags/Arrays/"},{"name":"sort","slug":"sort","permalink":"https://xqtony.github.io/tags/sort/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"}]},{"title":"比较Comparator与Comparable接口","date":"2023-05-25T21:54:15.297Z","path":"2023/05/26/comparable vs comparator/","text":"简单比较下Comparator与Comparable接口Comparator 和 Comparable 都是 Java 中用于比较对象大小的接口，但它们有以下区别： 接口位置不同：Comparable 接口位于 java.lang 包中，而 Comparator 接口位于 java.util 包中。 实现方式不同：实现 Comparable 接口的类需要重写 compareTo() 方法，而实现 Comparator 接口的类需要重写 compare() 方法。 使用场景不同：实现 Comparable 接口的类通常用于已经有一定顺序的情况下，例如对整数或字符串进行排序。而实现 Comparator 接口的类通常用于需要动态指定排序方式的情况下，例如对自定义对象进行排序。 排序方式不同：Comparable 接口是内部比较器，它定义了对象的自然顺序，即对象本身就有了固定的比较规则。而 Comparator 接口是外部比较器，它允许用户根据需要指定不同的比较规则。 综上所述，Comparable 接口适用于已经有一定顺序的情况下，而 Comparator 接口适用于需要动态指定排序方式的情况下。 以下是 Comparable 和 Comparator 的用法实例：Comparable 实例： 12345678910111213141516171819202122public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public int compareTo(Person other) &#123; return Integer.compare(this.age, other.age); &#125;&#125; 在这个例子中，我们定义了一个 Person 类，并实现了 Comparable 接口。在 compareTo() 方法中，我们使用 Integer.compare() 方法比较了两个 Person 对象的年龄大小关系，从而定义了 Person 对象的自然顺序。这样，我们就可以在使用 Collections.sort() 或 Arrays.sort() 方法时，直接对 &#96;Person 对象进行排序。 Comparator 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;public class PersonCompartor implements Comparator&lt;Person&gt; &#123; @Override public int compare(Person p1, Person p2) &#123; return Integer.compare(p1.getAge(), p2.getAge()); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Person[] people=new Person[]&#123;new Person(&quot;Tony&quot;, 20),new Person(&quot;Xiangqi&quot;, 10)&#125;; System.out.println(&quot;排序前&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; Arrays.sort(people,new PersonCompartor()); System.out.println(&quot;\\n排序后&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; &#125;&#125; 在这个例子中，我们同样定义了一个 Person 类，但没有实现 Comparable 接口。然后，我们创建了一个 PersonComparator 类，实现了 Comparator 接口，并重写了 compare() 方法。在 compare() 方法中，我们比较了两个 Person 对象的年龄大小关系，从而定义了 Person 对象的比较规则。这样，我们就可以在使用 Collections.sort() 或 Arrays.sort() 方法时，使用 PersonComparator 对象进行排序。 参考文献： Java中Comparable和Comparator区别小结","tags":[{"name":"compareTo","slug":"compareTo","permalink":"https://xqtony.github.io/tags/compareTo/"},{"name":"compare","slug":"compare","permalink":"https://xqtony.github.io/tags/compare/"},{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"AI辅助创作","slug":"AI辅助创作","permalink":"https://xqtony.github.io/tags/AI%E8%BE%85%E5%8A%A9%E5%88%9B%E4%BD%9C/"},{"name":"Comparator","slug":"Comparator","permalink":"https://xqtony.github.io/tags/Comparator/"},{"name":"Comparable","slug":"Comparable","permalink":"https://xqtony.github.io/tags/Comparable/"}]},{"title":"浅谈compareTo()方法","date":"2023-05-25T20:19:45.560Z","path":"2023/05/26/compareTo/","text":"下面这段代码使用了 compareTo() 方法，有问题吗？123456789class Employee implements Comparable &#123; private int id; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return this.id - emp.id; &#125;&#125; 使用减法看起来合乎逻辑，但实际上隐藏了溢出的问题。 当我们需要按照一定的规则进行排序的时候，通常要实现 Comparable 接口，并实现 compareTo 方法，规则如下： 1）如果当前对象小于另外一个对象，则 compareTo 方法必须返回负数；如果当前对象大于另外一个对象，则必须返回正数；如果两个对象相等，则返回零。 2）通常来说，compareTo 方法必须和 equals 方法一致，如果两个对象通过 equals 方法判断的结果为 true，那么 compareTo 必须返回零。 不过，JDK 中有一个反例，就是 BigDecimal。 12345BigDecimal bd1 = new BigDecimal(&quot;2.0&quot;);BigDecimal bd2 = new BigDecimal(&quot;2.00&quot;);System.out.println(&quot;equals: &quot; + bd1.equals(bd2));System.out.println(&quot;compareTo: &quot; + bd1.compareTo(bd2)); 输出结果如下所示： 12equals: falsecompareTo: 0 这是因为 JDK 认为 2.0 和 2.00 的精度不一样，所以不能 equals，但值确实是相等的。 3）不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 Integer.compareTo() 来进行比较。如果你想通过减法操作来提高性能，必须得确保两个操作数是正整数，或者确保两者相差的值小于 Integer.MAX_VALUE。 12345678910111213141516171819202122232425262728293031public class CompareDemo &#123; public static void main(String[] args) &#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); list.add(new Employee(1)); list.add(new Employee(Integer.MIN_VALUE)); list.add(new Employee(Integer.MAX_VALUE)); Collections.sort(list); System.out.println(list); &#125;&#125;class Employee implements Comparable &#123; private int id; public Employee(int id) &#123; this.id = id; &#125; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return this.id - emp.id; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; 程序的输出结果如下所示： 1[Employee&#123;id=1&#125;, Employee&#123;id=2147483647&#125;, Employee&#123;id=-2147483648&#125;] 排序就乱了。因为 Integer.MIN_VALUE - 1 变成了正数 2147483647。 回到最开始的问题，正确的写法应该是 123456789class Employee implements Comparable &#123; private int id; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return Integer.valueOf(this.id).compareTo(emp.id); &#125;&#125; 实际上，Integer.compareTo()底层是通过调用Integer.compare()方法实现的： 12345678public int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125;public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x == y) ? 0 : 1); &#125; 所以上面的问题可以重写为 123456789class Employee implements Comparable &#123; private int id; @Override public int compareTo(Object o) &#123; Employee emp = (Employee) o; return Integer.compare(this.id, emp.id); &#125;&#125; 值得注意的是，String类型只有compareTo方法，而没有compare方法。给出源代码进行参考： 12345678910111213141516171819public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; 可见String类型不需要compare方法。 基于这10道基础Java面试题，虐哭了多少人改写。 参考： List集合排序Collections.sort()方法的一个容易忽略的小问题","tags":[{"name":"compareTo","slug":"compareTo","permalink":"https://xqtony.github.io/tags/compareTo/"},{"name":"compare","slug":"compare","permalink":"https://xqtony.github.io/tags/compare/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://xqtony.github.io/tags/BigDecimal/"},{"name":"Java","slug":"Java","permalink":"https://xqtony.github.io/tags/Java/"},{"name":"二创","slug":"二创","permalink":"https://xqtony.github.io/tags/%E4%BA%8C%E5%88%9B/"}]},{"title":"MySQL数据库 - 基础篇","date":"2023-05-22T16:28:19.611Z","path":"2023/05/23/MySQL_DB_basic/","text":"概述是一种 关系型数据库：建立在关系模型上，由多张互相连接的二维表组成的数据库。关系数据库 特点：1. 使用表存储数据，格式统一，便于维护2. 使用SQL语言操作，标准统一，使用方便MySQL的数据模型从客户端到DBMS，再到数据库，最后到达数据库中的表 MySQL启动的命令 12net start mysql80 # 这里的mysql80是注册在Windows中的服务名称net stop mysql80 MySQL客户端连接MySQL自带的客户端命令行CMD执行命令： 1mysql -h 127.0.0.1 -P 3306 -u root -p SQLSQL通用语法1. SQL语句单行，多行均可，默认分号结尾2. 使用空格&#x2F;缩进以增加可读性3. 不区分大小写，推荐关键字使用大写4. 注释：单行注释：– 通用，# MySQL独有多行注释：&#x2F;**&#x2F;SQL分类：DDL: Data Definition Language 数据定义语言，用来定义数据库对象 （数据库，表，字段）DML: Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改DQL: Data Query Language 数据查询语言，用来查询数据库中表的记录DCL: Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限DDL-数据库操作:查询查询所有数据库 1SHOW DATABASES; 查询当前数据库 1SELECT DATABASE(); 创建 1CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则] 案例： 12create database if not exists test; -- 如果不存在，创建test数据库create database itheima default charset utf8mb4; -- 创建utf8mb4字符集的itheima 数据库 删除 1DROP DATABASE [IF EXISTS] 数据库名 使用数据库 1USE 数据库名 查询当前数据库全部表 1SHOW TABLES; 查询表结构 1DESC 表名 或者 DESCRIBE 表名 查询指定表的建表语句 1SHOW CREATE TABLE 表名 DDL-表操作-创建 123456CREATE TABLE 表名( 字段1 字段1类型[COMMENT 字段1注释], 字段2 字段2类型[COMMENT 字段2注释], ...... 字段n 字段n类型[COMMENT 字段n注释])[COMMENT 注释]; 第二章讲解InnoDB底层原理 DDL-表操作-数据类型主要分三类：数值类型，字符串类型，日期时间类型数值类型 实例： 12age TINYINT UNSIGNED # 0~255的整数score DOUBLE(4, 1) #100.0最长是4，填4，80.5，70.5，最多一位小数，填1。 字符串类型 定长&#x2F;变长字符串的区别 12char(10) # 长度固定为10，没用的部分用空格补位 --&gt; 性能好？varchar(10) # 长度最长不超过10，小于10时体现实际长度 --&gt; 性能较差 实例：用户名 username 用那个更好呢？答案：varchar(50)更好。因为用户的用户名不是定长的，使用varchar可以节约空间性别 gender 用哪个？答案：char(1)日期类型 实例： 1birthday date # 生日用date类型更合适 案例：根据需求创建表（设计合理的数据类型、长度） 答案： 123456789create table emp ( id int comment &#x27;编号&#x27;, workno varchar(10) comment &#x27;工号&#x27;, name varchar(10) comment &#x27;姓名&#x27;, gender char(1) comment &#x27;性别&#x27;, age tinyint unsigned comment &#x27;年龄&#x27;, idcard char(18) comment &#x27;身份证号&#x27;, entrydate date comment &#x27;入职时间&#x27;) comment &#x27;员工表&#x27;; DDL-表操作-修改添加字段 1ALTER TABLE 表名 ADD 字段名 类型（长度） [COMMENT 注释] [约束]; 案例：为emp表添加一个字段“昵称”为nickname，类型为varchar(20)答案： 1ALTER TABLE emp add nickname varchar(20) comment &#x27;昵称&#x27;; 修改数据类型 1ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型 1ALTER TABLE 表名 CHANGE 旧字段名 新字段名称 类型（长度） [COMMENT 注释] [约束]; 案例：将emp表的nickname 修改为username，类型为varchar(30)答案： 1ALTER TABLE emp change nickname username varchar(30) comment &#x27;用户名&#x27;; 删除字段 1ALTER TABLE 表名 DROP 字段名; 案例：删除emp中的username列答案： 1ALTER TABLE emp drop username; 修改表名 1ALTER TABLE 表名 RENAME TO 新表名; 案例：将emp表表名修改为employee 1ALTER TABLE emp RENAME TO employee; 删除表 1DROP TABLE [IF EXISTS] 表名; 删除指定表，并重新创建该表 1TRUNCATE TABLE 表名; MySQL图形化界面： MySQL WorkbenchDML-介绍DML的全称是Data Manipulation Lanagage (数据操作语言），用来对数据表中的数据记录进行增删改操作。添加数据 (INSERT)修改数据 (UPDATE)删除数据 (DELETE)DML-添加数据1. 给指定字段添加数据 1INSERT INTO 表名 (字段1， 字段2, ...) VALUES (值1， 值2, ...); 2. 给全部字段添加数据 1INSERT INTO 表名 VALUSE (值1， 值2, ...); 3. 批量添加数据 12INSERT INTO 表名 (字段名1，字段名2，...) VALUSE (值1，值2，...), VALUSE (值1，值2，...);INSERT INTO 表名 VALUSE (值1，值2，...), VALUSE (值1，值2，...); 注意： DML-修改数据UPDATE 表名 SET 字段名1&#x3D;值1, 字段名2&#x3D;值2, … [WHERE 条件];注意：如果修改的条件没有，则会修改整张表的数据。案例： 12345678-- id = 1 的名字修改为it 黑马update employee set name = &#x27;kelly&#x27; where id = 1;-- id = 1 的名字修改为Kelly, gender 修改为女update employee set name = &#x27;kelly&#x27;, gender = &#x27;W&#x27; where id = 1;-- 将所有员工的入职时间设定为2008-01-01update employee set entrydate = &#x27;2008-01-01&#x27;; DML-删除数据DELETE FROM 表名 [WHERE 条件];注意：DELETE语句的条件可有可无，没有的情况下会删除整张表的数据。DELETE语句不能删除某一个字段的值（可以使用UPDATE）。案例： 12345-- 删除gender为W的员工DELETE FROM employee WHERE gender = &#x27;W&#x27;;-- 删除所有员工DELETE FROM employee; DQL-介绍DQL是Data Query Language 的缩写，用来查询数据库中表的记录。查询关键字：SELECTDQL-语法 1234SELECT 字段列表 FROM 表名列表WHERE 条件列表 GROUP BY 分组字段列表HAVING 分组后条件列表 ORDER BY 排序字段列表LIMIT 分页参数 基本查询条件查询 WHERE聚合函数 count(), max(), min(), avg(), sum()分组查询 GROUP BY排序查询 ORDER BY分页查询 LIMITDQL-基本查询1. 查询返回多个字段 12SELECT 字段1，字段2，字段3... FROM 表名;SELECT * FROM 表名; 2. 设置别名 1SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名; 其中AS可以省略3. 去除重复记录 1SELECT DISTINCT 字段列表 FROM 表名; 案例：数据准备： 12345678910111213141516171819202122232425262728293031-- 数据准备CREATE TABLE emp( id INT, workno VARCHAR(10), name VARCHAR(10), gender CHAR(1), age TINYINT UNSIGNED, idcard CHAR(18), workaddress VARCHAR(50), entrydate DATE) COMMENT &#x27;员工表&#x27;;DESC emp;INSERT INTO emp VALUES(1, &#x27;1&#x27;, &#x27;aa&#x27;, &#x27;W&#x27;, 28, &#x27;123456789012345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(2, &#x27;2&#x27;, &#x27;ab&#x27;, &#x27;M&#x27;, 18, &#x27;123456789012335678&#x27;, &#x27;Dalian&#x27;, &#x27;2000-01-01&#x27;),(3, &#x27;3&#x27;, &#x27;ac&#x27;, &#x27;M&#x27;, 8, &#x27;123456789012345678&#x27;, &#x27;Beijing&#x27;, &#x27;2006-01-01&#x27;),(4, &#x27;4&#x27;, &#x27;ad&#x27;, &#x27;W&#x27;, 28, &#x27;123456783412345678&#x27;, &#x27;Dalian&#x27;, &#x27;2002-01-01&#x27;),(5, &#x27;5&#x27;, &#x27;ae&#x27;, &#x27;W&#x27;, 38, &#x27;123456783312345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(6, &#x27;6&#x27;, &#x27;af&#x27;, &#x27;M&#x27;, 68, &#x27;123456786012345678&#x27;, &#x27;Dalian&#x27;, &#x27;2000-01-06&#x27;),(7, &#x27;7&#x27;, &#x27;ag&#x27;, &#x27;W&#x27;, 28, &#x27;123456789012445678&#x27;, &#x27;Beijing&#x27;, &#x27;2007-01-01&#x27;),(8, &#x27;8&#x27;, &#x27;ah&#x27;, &#x27;M&#x27;, 8, &#x27;123456789012235678&#x27;, &#x27;Shanghai&#x27;, &#x27;2000-01-01&#x27;),(9, &#x27;9&#x27;, &#x27;ai&#x27;, &#x27;W&#x27;, 28, &#x27;123456789022345678&#x27;, &#x27;Beijing&#x27;, &#x27;2011-01-02&#x27;),(10, &#x27;10&#x27;, &#x27;aj&#x27;, &#x27;W&#x27;, 98, &#x27;123456722212345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(11, &#x27;11&#x27;, &#x27;ak&#x27;, &#x27;M&#x27;, 28, &#x27;123456555512345678&#x27;, &#x27;Shanghai&#x27;, &#x27;2000-01-01&#x27;),(12, &#x27;12&#x27;, &#x27;al&#x27;, &#x27;W&#x27;, 78, &#x27;123456789512345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(13, &#x27;13&#x27;, &#x27;am&#x27;, &#x27;M&#x27;, 16, &#x27;123456789712345678&#x27;, &#x27;Shanghai&#x27;, &#x27;1990-01-01&#x27;),(14, &#x27;14&#x27;, &#x27;an&#x27;, &#x27;W&#x27;, 18, &#x27;123456789872345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;),(15, &#x27;15&#x27;, &#x27;ao&#x27;, &#x27;M&#x27;, 2, &#x27;123456789012345678&#x27;, &#x27;Shanghai&#x27;, &#x27;2005-01-01&#x27;),(16, &#x27;16&#x27;, &#x27;aq&#x27;, &#x27;W&#x27;, 22, &#x27;123456782362345678&#x27;, &#x27;Beijing&#x27;, &#x27;2000-01-01&#x27;); 123456789101112131415-- 基本查询-- 1. 查询指定字段，name，workno，age返回SELECT name, workno, age FROM emp;-- 2. 查询所有字段返回SELECT * FROM emp; -- 尽量不要写*，因为效率低而且不安全，相比之下写出来所有字段更好SELECT id, workno, name, gender, age, idcard, workaddress, entrydate FROM emp;-- 3. 查询所有员工的工作地址SELECT workaddress as &#x27;工作地址&#x27; FROM emp;SELECT workaddress &#x27;工作地址&#x27; FROM emp;-- 4. 查询员工的上班地址（不要重复）SELECT DISTINCT workaddress &#x27;工作地址&#x27; FROM emp; DQL-条件查询1. 语法 1SELECT 字段列表 FROM 表名 WHERE 条件列表; 2. 条件比较运算符![]逻辑运算符 案例： 123456789101112131415161718192021222324252627-- 条件查询-- 1. 查询年龄等于98的员工SELECT * FROM emp WHERE age = 98;-- 2. 查询年龄小于20 的员工SELECT * FROM emp WHERE age &lt; 20;-- 3. 查询年龄小于等于20的员工信息SELECT * FROM emp WHERE age &lt;= 20;-- 4. 查询没有身份证号的员工信息SELECT * FROM emp WHERE idcard IS NULL;-- 5. 查询有身份证号的员工SELECT * FROM emp WHERE idcard IS NOT NULL;-- 6. 查询年龄不是88的员工SELECT * FROM emp WHERE age &lt;&gt; 88;SELECT * FROM emp WHERE age != 88;-- 7. 查询年龄在15~20岁的员工SELECT * FROM emp WHERE age BETWEEN 15 AND 20;SELECT * FROM emp WHERE age &gt;= 15 AND age &lt;= 20;-- 8. 查询性别为女而且年龄小于25的员工信息SELECT * FROM emp WHERE gender = &#x27;W&#x27; AND age &lt; 25;-- 9. 查询年龄等于18或20或40的员工信息SELECT * FROM emp WHERE age = 18 OR age = 20 OR age = 40;SELECT * FROM emp WHERE age IN (18, 20, 40);-- 10. 查询名字是两个字的员工的信息SELECT * FROM emp WHERE name like &#x27;__&#x27;;-- 11. 查询身份证号最后一位是X的员工信息SELECT * FROM emp WHERE idcard LIKE &#x27;%X&#x27;;SELECT * FROM emp WHERE idcard LIKE &#x27;_________________X&#x27;; DQL-分组查询语法： 1SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件] WHERE和HAVING的区别- 执行时间不同，WHER是分组前过滤，HAVING是分组后过滤- 判断条件不同，WHERE不能对聚合函数进行判断，HAVING可以案例： 1234567-- 分组查询-- 1. 根据性别分组，统计男性员工和女性员工的数量SELECT gender, COUNT(*) total FROM emp GROUP BY gender;-- 2. 根据性别分组，统计男性员工和女性员工的平均年龄SELECT gender, AVG(age) avg_age FROM emp GROUP BY gender;-- 3. 查询年龄小于45的员工，并根据工作地址进行分组，获取员工数量&gt;=3的工作地址SELECT workaddress, COUNT(*) address_count FROM emp WHERE age &lt; 45 GROUP BY workaddress HAVING address_count &gt;= 3; 注意：- 执行顺序：where &gt; 聚合函数 &gt; having- 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无意义DQL-排序查询语法： 1SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： 12ASC: 升序 （默认值）DESC: 降序 案例： 1234567-- 排序查询-- 1 根据年龄对公司的员工进行升序排序SELECT * FROM emp ORDER BY age ASC; -- ASC可以省略；降序则改为DESC-- 2 根据入职时间对员工进行降序排序SELECT * FROM emp ORDER BY entrydate DESC;-- 3 根据年龄对公司员工进行升序排序，如果年龄相同再按入职时间进行降序排序SELECT * FROM emp ORDER BY age ASC, entrydate DESC; DQL-分页查询语法： 1SELECT 字段列表 FROM 表名 LIMIT 起始索, 查询返回记录数; 注意：- 起始索引从0开始，其实索引 &#x3D; (查询页码 - 1) * 每页显示记录数- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL是LIMIT- 如果查询的是第一页的数据，起始索引可以省略，直接简写为LIMIT 10案例： 1234567-- 分页查询-- 1. 查询第一页员工数据，每页显示10条记录SELECT * FROM emp LIMIT 0, 10;SELECT * FROM emp LIMIT 10;-- 2. 查询第二页员工数据，每页显示10条记录SELECT * FROM emp LIMIT 10, 10; -- (页码 - 1)*页展示记录数 DQL 案例课 12345678910-- 案例-- 1. 查询年龄为20，21，22，23岁的女性员工信息SELECT * FROM emp WHERE age IN (20, 21, 22, 23) AND gender = &#x27;W&#x27;;-- 2. 查询性别为男并且年龄在20-40岁（含）且姓名为两个字的员工SELECT * FROM emp WHERE gender = &#x27;M&#x27; AND ( age BETWEEN 20 AND 40 ) AND name LIKE &#x27;__&#x27;;-- 3. 统计员工表中，年龄小于60岁的男性和女性员工的数量。SELECT gender, COUNT(*) age_count FROM emp WHERE age &lt; 60 GROUP BY gender;-- 4. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按照年龄升序排序，年龄相同按照入职时间降序排序SELECT name, age FROM emp WHERE age &lt;= 35 ORDER BY age, entrydate DESC;-- 5. 查询性别为W且年龄在20-40（含）以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按照入职时间升序SELECT * FROM emp WHERE gender = &#x27;W&#x27; AND ( age BETWEEN 20 AND 40 ) ORDER BY age, entrydate LIMIT 5; DQL - 执行顺序 12345678910111213141516171819SELECT (4)FROM (1)WHERE (2)GROUP BY (3)HAVINGORDER BY (5)LIMIT (6)=&gt;FROM WHEREGROUP BYHAVINGSELECTORDER BYLIMIT 案例： 1234567891011-- 查询年龄大于15的员工的姓名、年龄、并根据年龄进行升序排序SELECT name, age FROM emp WHERE age &gt; 15 ORDER BY age;-- 顺序验证SELECT name, age FROM emp E WHERE E.age &gt; 15 ORDER BY age; -- FROM 第一SELECT E.name, E.age FROM emp E WHERE E.age &gt; 15 ORDER BY age; -- SELECT 在FROM和WHERE之后SELECT E.name ename, E.age EAGE FROM emp E WHERE EAGE &gt; 15 ORDER BY age; -- 失败：SELECT 在FROM和WHERE之后执行SELECT E.name ename, E.age EAGE FROM emp E WHERE E.age &gt; 15 ORDER BY EAGE; -- 成功：SELECT 在ORDER BY之前执行 DCL-介绍DCL 全称 Data Control Language （数据控制语言），用来管理数据库用户、控制数据库的访问权限DCL-管理用户1. 查询用户 12USE mysql;SELECT * FROM user; 2. 创建用户 1CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;; 3. 修改用户密码 1ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;; 4. 删除用户 1DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;; 案例： 12345678910111213141516-- DCLuse mysql;show tables;select * from user;-- 创建用户itcast，只能够在localhost 访问，密码123456create user &#x27;itcast&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;-- 创建用户heima，可以在任意机器访问该数据库，密码123456create user &#x27;heima&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;-- 修改用户heima的密码为1234alter user &#x27;heima&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;1234&#x27;;-- 删除itcast@localhost用户drop user &#x27;itcast&#x27;@&#x27;localhost&#x27;; 注意：- 主机名可以用’%‘通配- 这类SQL开发人员使用较少，主要是DBA (Database Administrator 数据库管理员)使用DCL-权限控制 1. 查询权限 1SHOW GRANTS FOR &#x27;用户名&#x27;@‘主机名’; 2. 授予权限 1GRANT 权限列表 ON 数据库.表名 TO &#x27;用户名&#x27;@‘主机名’; 3. 撤销权限 1REMOVE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@‘主机名’; 案例： 12345678-- 查询权限show grants for &#x27;heima&#x27;@&#x27;%&#x27;;-- 授予权限grant all on itcast.* to &#x27;heima&#x27;@&#x27;%&#x27;;-- 撤销权限revoke all on itcast.* from &#x27;heima&#x27;@&#x27;%&#x27;; 注意： 总结：1. 用户管理 123CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;ALTER USER &#x27;usernmae&#x27;@&#x27;host&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;DROP USER &#x27;username&#x27;@&#x27;host&#x27;; 2. 权限控制 12GRANT 权限列表 ON 数据库名.表名 TO ‘用户名&#x27;@&#x27;主机名&#x27;;REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;; 函数函数是指可以被另一段程序直接调用的的程序或代码。 字符串函数 数值函数 日期函数 流程函数 字符串函数演示： 123456789101112131415161718192021-- 函数演示-- concatselect concat(&#x27;Hello &#x27;, &#x27;MySQL&#x27;);-- lowerselect lower(&#x27;Hello&#x27;);-- upperselect upper(&#x27;Hello&#x27;);-- lpadselect lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- rpadselect rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- trimselect trim(&#x27; Hello MySQL &#x27;);-- substringselect substring(&#x27;Hello MySQL&#x27;, 1, 5); # 这里字符串索引从1开始 案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补充0。比如1号员工应该为00001。答案： 1234-- 1. 员工号补0.use itcast;select * from emp;update emp set workno = lpad(workno, 5, &#x27;0&#x27;); 数值函数常见的数值函数如下： 演示 12345678910111213-- 数值函数-- ceilselect ceil(1.1);-- floorselect floor(1.5);-- modselect mod(3, 4); # 3除以4取余select mod(6, 4);-- randselect rand(); # 获得一个0-1的随机数-- roundselect round(2.345, 2);select round(2.344, 2); 案例通过数据库的函数，生成一个六位数的随机验证码 1234-- 2.通过数据库的函数，生成一个六位数的随机验证码selectsubstring(rand(), 3, 6); # 用substring截取select lpad(round(rand() * 1000000, 0), 6, &#x27;0&#x27;); # 计算，取整，填充 日期函数常见的日期函数 演示： 12345678910111213141516-- 日期函数-- curdate()select curdate();-- curtime()select curtime();-- now()select now();-- YEAR, MONTH, DAYselect year(now()), month(now()), day(now());-- date_add(date, INTERVAL expr type)select date_add(now(), INTERVAL 70 day); # 70天之后，70天之前用负值即可-- date_diffselect datediff(now(), &#x27;2022-12-01&#x27;); # 第一个日期减去第二个日期 案例： 12-- 查询所有员工的入职天数，并根据入职天数倒序排序select name, entrydate, datediff(now(), entrydate) 入职日期 from emp order by 入职日期 desc; #可以用中文。 流程函数流程函数实现条件筛选，提高语句的效率： 1234IF(value, t, f)IFNULL(value1, value2)CASE WHEN [val1] THEN [res1] ... ELSE [default] ENDCASE [expr] WHEN [val1] THEN [res1] .. ELSE [default] END 演示： 12345678910111213141516171819-- 流程函数-- ifselect if (true, &#x27;ok&#x27;, &#x27;error&#x27;);-- ifnullselect ifnull (&#x27;ok&#x27;, &#x27;Default&#x27;); -- 第一个值为非null则返回第一个值，若为null则返回第二个值select ifnull (&#x27;&#x27;, &#x27;Default&#x27;);select ifnull (null, &#x27;Default&#x27;);-- case when then else end-- 需求：查询emp员工姓名和工作地址（北京/上海 ---&gt;一线城市，其他---&gt;二线城市）select name, case workaddress when &#x27;Beijing&#x27; then &#x27;一线城市&#x27; when &#x27;Shanghai&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; endfrom emp; 案例： 1234567891011121314151617181920-- 案例：统计班级各个学员的成绩，展示的规则如下：-- &gt;= 85，展示优秀 -- &gt;= 60, 展示及格 -- 否则， 展示不及格 create table score( id int comment &#x27;ID&#x27;, name varchar(20) comment &#x27;姓名&#x27;, math int comment &#x27;数学&#x27;, english int comment &#x27;英语&#x27;, chinese int comment &#x27;语文&#x27;) comment &#x27;学员成绩表&#x27;;insert into scorevalues (1, &#x27;Tom&#x27;, 67, 88, 95), (2, &#x27;Rose&#x27;, 23, 66, 90), (3, &#x27;Jack&#x27;, 56, 98, 76);select * from score;select id, name, case when math &gt;= 85 then &#x27;优秀&#x27; when math between 60 and 85 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;数学成绩&#x27;, case when english &gt;= 85 then &#x27;优秀&#x27; when english between 60 and 85 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;英语成绩&#x27;, case when chinese &gt;= 85 then &#x27;优秀&#x27; when chinese between 60 and 85 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;语文成绩&#x27;from score; 总结字符串函数 1234567concatlowerupperlpad 左填充rpad 右填充trim 去除左右空格substring 字符串截取 数值函数 12345ceilfloormodrandround 四舍五入，保留指定位小数 日期函数 12345678curdatecurtimenowyearmonthdaydate_adddatediff 第一个日期减去第二个日期 流程函数 123ififnullcase [...] when.. then... else... end 约束概述：常见的约束有哪些 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据 目的：保证数据库中数据的正确，有效性和完整性 分类： 约束演示案例：根据需求，完成表的创建 12345678910111213141516171819202122232425262728293031id: primary key, auto_incrementname: not null, uniqueage: checkstatus: defaultgender: N/A-- 约束create database itheima default charset utf8mb4;use itheima;create table user( id int primary key auto_increment comment &#x27;主键&#x27;, name varchar(10) not null unique comment &#x27;姓名&#x27;, age int check(age &gt; 0 and age &lt; 120) comment &#x27;年龄&#x27;, -- 用and或&amp;&amp;都可以 status char(1) default &#x27;1&#x27; comment &#x27;状态&#x27;, gender char(1)) comment &#x27;用户表&#x27;;select * from user;insert into user(name, age, status, gender) values (&#x27;Tom1&#x27;, 19, &#x27;1&#x27;, &#x27;男&#x27;), (&#x27;Tom2&#x27;, 25, &#x27;0&#x27;, &#x27;男&#x27;);insert into user(name, age, status, gender) values (&#x27;Tom3&#x27;, 19, &#x27;1&#x27;, &#x27;男&#x27;);insert into user(name, age, status, gender) values (null, 19, &#x27;1&#x27;, &#x27;男&#x27;); -- 出错，因为不可以出错insert into user(name, age, status, gender) values (&#x27;Tom3&#x27;, 19, &#x27;1&#x27;, &#x27;男&#x27;); -- 不可重复执行，因为存在唯一约束 insert into user(name, age, status, gender) values (&#x27;Tom4&#x27;, 80, &#x27;1&#x27;, &#x27;男&#x27;); -- id 是5，虽然刚才插入没有成功，但是id已经被申请过了 insert into user(name, age, status, gender) values (&#x27;Tom5&#x27;, -1, &#x27;1&#x27;, &#x27;男&#x27;); -- 检查约束生效 insert into user(name, age, status, gender) values (&#x27;Tom5&#x27;, 121, &#x27;1&#x27;, &#x27;男&#x27;); -- 检查约束生效 insert into user(name, age, gender) values (&#x27;Tom6&#x27;, 121, &#x27;男&#x27;);insert into user(name, age, gender) values (&#x27;Tom5&#x27;, 120, &#x27;男&#x27;); 拓展：约束的修改 12345-- 发现建表的时候约束设置的不正确,如何修改 show create table user; -- 查看现有约束的名称alter table user drop constraint user_chk_1; -- 删除现有约束delete from user where age = 121; -- 如果有数据不满足约束,去除之 alter table user add constraint user_chk_1 check (age &gt; 0 and age &lt;= 120); -- 添加新的约束,操作结束 外键约束概念外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性 具有外键的表称为子表，被关联的表叫做父表注意：数据库层面，未建立外键关联，所以无法保证数据的一致性和完整性。演示： 12345678910111213141516171819202122232425262728-- 外键约束 -- 准备数据create table dept( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;部门名称&#x27;) comment &#x27;部门表&#x27;; insert into dept (id, name) values (1, &#x27;研发部&#x27;), (2, &#x27;市场部&#x27;), (3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;);create table emp ( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;姓名&#x27;, age int comment &#x27;姓名&#x27;, job varchar(20) comment &#x27;职位&#x27;, salary int comment &#x27;薪资&#x27;, entrydate date comment &#x27;入职时间&#x27;, managerid int comment &#x27;直属领导ID&#x27;, dept_id int comment &#x27;部门ID&#x27;) comment &#x27;员工表&#x27;;insert into emp (name, age, job, salary, entrydate, managerid, dept_id) values (&#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5), (&#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),(&#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1), (&#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),(&#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1), (&#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1);select * from emp;select * from dept;-- 以上,没有设置物理外键,无法保证数据之间的一致性和完整性 语法：添加外键 1234567891011121314151617181920CREATE TABLE 表名( 字段名 数据类型, .. [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);案例：delete from dept where id = 1; -- 成功删除 insert into dept (id, name) values (1, &#x27;研发部&#x27;);-- 添加外键 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);commit;delete from dept where id = 1; -- Cannot delete or update a parent row: a foreign key constraint fails-- 删除外键 alter table emp drop foreign key fk_emp_dept_id;delete from dept where id = 1; -- 删除成功 删除&#x2F;更新行为 123ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段）REFERENCES 主表 （主表字段名）ON UPDATE CASCADE ON DELETE CASCADE; 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758-- 外键的删除和更新行为 alter table emp add constraint fk_emp_dept_idforeign key(dept_id) references dept(id)on update cascade on delete cascade; -- 级联更新/删除 -- 级联更新操作 select * from dept;update dept set id = 6 where name = &#x27;研发部&#x27;;commit;select * from emp; -- 查看子表，的确更新为6了，这就是cascade的作用 delete from dept where id = 6; -- 子表数据也被删除了 -- SET NULL 操作 drop table emp;drop table dept;-- 准备数据create table dept( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;部门名称&#x27;) comment &#x27;部门表&#x27;; insert into dept (id, name)values (1, &#x27;研发部&#x27;),(2, &#x27;市场部&#x27;), (3, &#x27;财务部&#x27;),(4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;);create table emp ( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;姓名&#x27;, age int comment &#x27;姓名&#x27;, job varchar(20) comment &#x27;职位&#x27;, salary int comment &#x27;薪资&#x27;, entrydate date comment &#x27;入职时间&#x27;, managerid int comment &#x27;直属领导ID&#x27;, dept_id int comment &#x27;部门ID&#x27;) comment &#x27;员工表&#x27;;insert into emp (name, age, job, salary, entrydate, managerid, dept_id)values (&#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),(&#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),(&#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),(&#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),(&#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),(&#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1);select * from dept;select * from emp;-- 添加外键 alter table emp add constraint fk_emp_dept_id foreign key(dept_id)references dept(id) on update set null on delete set null; -- set null更新/删除 -- 删除id = 1的数据delete from dept where id = 1;select * from emp; -- 可见所有emp 原有dept_id = 1的数据现在 dept_id的值为 null 总结1. 非空约束 not null2. 唯一约束 unique3. 主键约束 primary key (自增: AUTO_INCREMENT， ORACLE没有这个，而是SEQUENCE)4. 默认约束 default5. 检查约束 check6. 外键约束 foreign key多表查询多表关系各个表结构之间存在各种联系：一对多 （多对一）多对多一对一一对多（多对一）案例：部门 与 员工 的关系关系：一个部门对应多个员工，一个员工对应一个部门实现：再多的一方建立外键，只想一的一方的主键 多对多案例：学生 与 课程的关系关系：一个学生可以选择多门课程，一门课程也可以供多个学生选择实现：建立第三张中间表，中间层至少包含两个外键，分别关联两方主键 案例： 1234567891011121314151617181920212223242526272829303132333435-- 多对多 -- 学生表create table student ( id int auto_increment primary key comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;姓名&#x27;, no varchar(10) comment &#x27;学号&#x27;) comment &#x27;学生表&#x27;;insert into studentvalues (null, &#x27;黛绮丝&#x27;, &#x27;2000100101&#x27;),(null, &#x27;谢逊&#x27;, &#x27;2000100102&#x27;),(null, &#x27;殷天正&#x27;, &#x27;2000100103&#x27;),(null, &#x27;韦一笑&#x27;, &#x27;2000100104&#x27;);-- 课程表 create table course( id int auto_increment primary key comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;课程名称&#x27;) comment &#x27;课程表&#x27;;insert into course values (null, &#x27;Java&#x27;), (null, &#x27;PHP&#x27;), (null, &#x27;MySQL&#x27;), (null, &#x27;Hadoop&#x27;);-- 学生课程关系表 create table student_course( id int auto_increment comment &#x27;主键&#x27; primary key, studentid int not null comment &#x27;学生ID&#x27;, courseid int not null comment &#x27;课程ID&#x27;, constraint fk_courseid foreign key (courseid) references course (id), constraint fk_student_id foreign key (studentid) references student(id)) comment &#x27;学生课程中间表&#x27;;insert into student_course values (null, 1, 1), (null, 1, 2), (null, 1, 3), (null, 2, 2), (null, 2, 3), (null, 3, 4);describe student_course;select * from studenstudent_coursestudent_coursestudent_coursestudent_coursestudent_courset_course; .一对一案例：用户 和 用户详情的关系关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）图例：![] 案例： 12345678910111213141516171819202122232425262728293031-- 一对一create table tb_user ( id int auto_increment primary key comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender char(1) comment &#x27;1: 男，2: 女&#x27;, phone char(11) comment &#x27;手机号&#x27;) comment &#x27;用户基本信息表&#x27;;create table tb_user_edu ( id int auto_increment primary key comment &#x27;主键ID&#x27;, degree varchar(20) comment &#x27;学历&#x27;, major varchar(50) comment &#x27;专业&#x27;, primaryschool varchar(50) comment &#x27;小学&#x27;, middleschool varchar(50) comment &#x27;中学&#x27;, university varchar(50) comment &#x27;大学&#x27;, userid int UNIQUE comment &#x27;用户ID&#x27;, constraint fk_userid foreign key (userid) references tb_user(id)) comment &#x27;用户教育信息表&#x27;;insert into tb_user(id, name, age, gender, phone) values(null, &#x27;黄渤&#x27;, 45, &#x27;1&#x27;, &#x27;18800001111&#x27;),(null, &#x27;冰冰&#x27;, 35, &#x27;2&#x27;, &#x27;18800002222&#x27;),(null, &#x27;码云&#x27;, 55, &#x27;1&#x27;, &#x27;18800008888&#x27;),(null, &#x27;李彦宏&#x27;, 50, &#x27;1&#x27;, &#x27;18800009999&#x27;);insert into tb_user_edu values(null, &#x27;本科&#x27;, &#x27;舞蹈&#x27;, &#x27;青岛市第一小学&#x27;, &#x27;青岛市第一中学&#x27;, &#x27;北京电影学院&#x27;, 1),(null, &#x27;硕士&#x27;, &#x27;表演&#x27;, &#x27;朝阳区第一小学&#x27;, &#x27;朝阳区第一中学&#x27;, &#x27;上海戏剧学院&#x27;, 2),(null, &#x27;本科&#x27;, &#x27;英语&#x27;, &#x27;杭州市第一小学&#x27;, &#x27;杭州市第一中学&#x27;, &#x27;杭州示范大学&#x27;, 3),(null, &#x27;本科&#x27;, &#x27;计算机&#x27;, &#x27;阳泉第一小学&#x27;, &#x27;阳泉第一中学&#x27;, &#x27;清华大学&#x27;, 4); 多表查询概述概述：指从多张表中查询数据笛卡尔积：指在数学中，两个集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 案例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 数据准备 drop table emp;drop table dept;create table dept( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;部门名称&#x27;) comment &#x27;部门表&#x27;; insert into dept (id, name) values (1, &#x27;研发部&#x27;),(2, &#x27;市场部&#x27;), (3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;),(5, &#x27;总经办&#x27;), (6, &#x27;人事部&#x27;);create table emp ( id int auto_increment comment &#x27;ID&#x27; primary key, name varchar(50) not null comment &#x27;姓名&#x27;, age int comment &#x27;姓名&#x27;, job varchar(20) comment &#x27;职位&#x27;, salary int comment &#x27;薪资&#x27;, entrydate date comment &#x27;入职时间&#x27;, managerid int comment &#x27;直属领导ID&#x27;, dept_id int comment &#x27;部门ID&#x27;) comment &#x27;员工表&#x27;;insert into emp (name, age, job, salary, entrydate, managerid, dept_id)values(&#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),(&#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),(&#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),(&#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),(&#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),(&#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1),(&#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;, 8500, &#x27;2002-10-12&#x27;, 1, 1),(&#x27;周芷若&#x27;, 19, &#x27;会计&#x27;, 48000, &#x27;2006-10-12&#x27;, 7, 3),(&#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;, 5250, &#x27;2009-10-12&#x27;, 7, 3),(&#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;, 12500, &#x27;2004-10-12&#x27;, 1, 2),(&#x27;路障可&#x27;, 56, &#x27;职员&#x27;, 3750, &#x27;2006-10-12&#x27;, 10, 2),(&#x27;和笔翁&#x27;, 19, &#x27;职员&#x27;, 3750, &#x27;2007-10-12&#x27;, 10, 2),(&#x27;房东白&#x27;, 19, &#x27;职员&#x27;, 5500, &#x27;2009-10-12&#x27;, 102, 2),(&#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;, 14000, &#x27;2004-10-12&#x27;, 1, 4),(&#x27;玉莲舟&#x27;, 38, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),(&#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),(&#x27;陈友谅&#x27;, 42, &#x27;null&#x27;, 2000, &#x27;2011-10-12&#x27;, 1, null);alter table emp add constraint foreign key fk_deptid (dept_id)references dept(id);-- 多表查询 select * from emp, dept; -- 查出来的结果好像比想象中要多 - 笛卡尔积 17 * 6 = 102 条select * from emp, dept where emp.dept_id = dept.id; 多表查询分类- 连接查询 - 内连接: 相当于查询A.B交集部分的数据 外连接: 左外连接: 查询左表中的所有数据，以及交集部分数据 右外连接：查询右表中的所有数据，以及交集部分数据 自连接：当前表与自身的连接查询，自连接必须使用表别名\\ 子查询内连接内连接查询语法： 隐式内连接： 1select 字段列表 from 表1, 表2 where 条件...; 显式内连接： 1select 字段列表 from 表1 [INNER] join 表2 on 连接条件...; 案例： 12345678910-- 内连接演示-- 1. 查询每一个员工的姓名,以及关联的部门的名称 (隐式内连接实现) select e.name, d.name from emp e, dept d where e.dept_id = d.id; -- 起别名之后不能直接用表名访问字段了 select emp.name, dept.name from emp, dept where emp.dept_id = dept.id;-- 2. 查询每一个员工的姓名以及关联的部门名称(显式内连接实现) select e.name, d.name from emp e inner join dept don e.dept_id = d.id; 外连接语法： 左外： 1select 字段名 from 表1 left [outer] join 表2 on 条件... ; 右外： 1select 字段名 from 表1 right [outer] join 表2 on 条件... ; 案例： 12345678910-- 外连接演示 -- 1. 查询emp表所有数据， 和对应的部门信息 （左连接）select e.*, d.name from emp e left join dept d on e.dept_id = d.id;select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;-- 2. 查询dept表中所有数据，和对应的员工信息 （右连接） select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;-- 等价于：select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id; 自连接语法： 1select 字段列表 from 表A 别名A join 表A 别名B on 条件... ; 自联结查询可以是内连接也可以是外连接案例： 12345678910-- 内连接演示 -- 1. 查询员工及其所属的领导名字 -- 表结构：emp表select a.name employee, b.name manager from emp a, emp bwhere a.managerid = b.id;-- 2. 查询所有员工emp及其领导的名字emp，如果员工没有领导也需要查询出来 -- 表结构：emp e1, emp e2select e1.name employee, e2.name boss from emp e1left join emp e2 on e1.managerid = e2.id; -- 左外 联合查询关键字：union, union all语法： 123select 字段列表 表A ...UNION [ALL]select 字段列表 表B ... ; 案例： 1234567-- union all, union-- 1. 将薪资低于5000的员工，和年龄大于50的员工全部查询出来 select * from emp where salary &lt; 5000union # union合并后去重，union all则没有去重 select * from emp where age &gt; 50;# 如果第二个查询只查询name，则无法使用union因为列数量不同 小结： 联合查询多张表的列数必须保持一致，字段类型也必须一致 union all 直接合并，union则会去重 子查询概念：SQL语句中嵌套SELECT语句，成为嵌套查询，又称子查询语法： 1select * from t1 where column1 = (select column1 from t2); 注意 - 子查询外部语句可以是insert&#x2F;update&#x2F;delete&#x2F;select的任何一个。分类：子查询结果不同，可以分为： 标量子查询 （子查询结果为单个值） 列子查询 （子查询结果为一列） 行子查询 （子查询结果为一行） 表子查询 （子查询结果为多行多列）根据子查询位置，分为：WHERE之后，FROM之后，SELECT之后。标量子查询：概念：子查询返回结果为单个值（数字，字符串，日期等），最简单的形式，这种子查询称为标量子查询。常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;案例： 12345678910111213141516171819202122-- 标量子查询 -- 1. 查询销售部所有员工信息 -- a. 查询销售部部门idselect id from dept where name = &#x27;销售部&#x27;;-- b. 根据部门id查询员工信息 select * from emp where dept_id = 4;-- 使用子查询 select * from emp where dept_id =(select id from dept where name = &#x27;销售部&#x27;);-- 使用外连接 select e.* from emp e join dept d on e.dept_id = d.idwhere d.name = &#x27;销售部&#x27;;-- 2. 查询在“房东白”入职之后的员工信息 -- a. 查询房东白的入职时间 select entrydate from emp where emp.name = &#x27;房东白&#x27;;-- b. 查询比房东白入职晚的员工 select * from emp where entrydate &gt; &#x27;2009-10-12&#x27;;-- 使用子查询 select * from emp where entrydate &gt;(select entrydate from emp where name = &#x27;房东白&#x27;); 列子查询：概念：子查询返回的结果是一列（可以是多行），这种子查询称为列子查询常用的操作符：IN, NOT IN, ANY, SOME, ALL 案例： 123456789101112131415161718192021222324252627282930313233-- 列子查询 -- 1. 查询“销售部”和“市场部”的所有员工信息 -- a. 找到销售部和市场部的部门idselect id from dept where name in (&#x27;销售部&#x27;, &#x27;市场部&#x27;);-- b. 根据部门id，查询员工信息 select * from emp where dept_id in(select id from dept where name in (&#x27;销售部&#x27;, &#x27;市场部&#x27;));-- 2. 查询比财务部所有人工资都高的员工信息-- 标量子查询 select * from emp a where salary &gt; ( select max(salary) from emp where dept_id in(select id from dept where name = &#x27;财务部&#x27;));-- 列子查询 select * from emp where salary &gt; all (select salary from emp where dept_id in(select id from dept where name = &#x27;财务部&#x27;));-- 3. 比研发部任意一人工资高的员工信息 -- 列子查询 select * from emp where salary &gt; any (select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;));-- 标量子查询select * from emp where salary &gt; (select min(e.salary) from emp e join dept d on e.dept_id = d.idwhere d.name = &#x27;研发部&#x27;); 行子查询概念：子查询返回的结果是一行（多列的）常用操作符：&#x3D;, &lt;&gt;, IN, NOT IN案例： 1234-- 行子查询 -- 查询与张无忌薪资和直属领导相同的员工信息 select * from emp where (salary, managerid) = (select salary, managerid from emp where name = &#x27;张无忌&#x27;); 表子查询概念：子查询返回的结果是多行多列，这种子查询叫做表子查询常用操作符：IN案例： 1234567891011-- 表子查询 -- 1. 查询与路障可，宋远桥的职位和薪资相同的员工 select * from emp where (job, salary) in (select job, salary from emp where name in (&#x27;路障可&#x27;, &#x27;宋远桥&#x27;));-- 2. 查询入职日期是“2006-01-01”之后的员工信息及其部门信息 select a.*, b.* from dept a right join(select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;) bon a.id = b.dept_id; 多表查询案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120-- 多表查询案例 create table salgrade ( grade int, losal int, hisal int) comment &#x27;薪资等级表&#x27;;insert into salgrade values(1, 0, 3000),(2, 3001, 5000),(3, 5001, 8000),(4, 8001, 10000),(5, 10001, 15000),(6, 15001, 20000),(7, 20001, 25000),(8, 25001, 30000);-- 1. 查询员工的姓名，年龄，职位，部门信息（隐式内连接） select e.name, e.age, e.job, d.name from emp e, dept dwhere e.dept_id = d.id;-- 2. 查询年龄小于30岁的员工的姓名，年龄，职位，部门信息（显式内连接） select e.name, e.age, e.job, d.namefrom emp e join dept don e.dept_id = d.idwhere e.age &lt; 30;-- 3. 查询拥有员工的部门的id，部门名称 select distinct d.id, d.name from dept dinner join emp eon e.dept_id = d.id;-- 4. 查询年龄大于40岁的员工，及其归属的部门名称；如果员工没有部门，也要展示出来 select e.*, d.name from emp e left join dept don e.dept_id = d.idwhere e.age &gt; 40;-- 5. 查询所有员工的工资等级 select e.*, sg.grade, sg.losal, sg.hisal fromemp e left join salgrade sgon e.salary &gt;= sg.losal and e.salary &lt;= sg.hisal;select e.*, sg.grade fromemp e, salgrade sgwhere e.salary between sg.losal and sg.hisal;-- 6. 查询研发部所有员工的信息及工资等级 select d.name, e.*, sg.grade fromemp e join salgrade sg join dept don e.salary between sg.losal and sg.hisaland e.dept_id = d.idwhere d.name = &#x27;研发部&#x27;;SELECT d.name, e.*, sg.gradeFROM emp e, dept d, salgrade sgWHERE e.salary BETWEEN sg.losal AND sg.hisal AND e.dept_id = d.id AND d.name = &#x27;研发部&#x27;;-- ctrl + B -- 7. 查询研发部的员工的平均工资 select avg(e.salary) &#x27;研发部平均工资&#x27; from emp e, dept dwhere e.dept_id = d.idand d.name = &#x27;研发部&#x27;;-- 8. 查询工资比灭绝高的员工信息 -- 自连接 select e2.* from emp e1, emp e2where e1.name = &#x27;灭绝&#x27;and e2.salary &gt; e1.salary;-- 子查询select * from emp where salary &gt; (select salary from emp where name = &#x27;灭绝&#x27;);-- 9. 查询比平均薪资高的员工信息 select * from emp where salary &gt; (select avg(salary) from emp);-- 10. 查询低于本部门平均薪资的员工 select e.*, avgsal.sal from emp e join (select dept_id, avg(salary) sal from emp group by dept_id) avgsalon e.dept_id = avgsal.dept_idwhere e.salary &lt; avgsal.sal;-- 可以用子查询，目测效率更低因为对于每一行子查询都需要重新计算一下本部门平均薪资 -- 第一步：计算本部门平均薪资：select avg(salary) from emp where dept_id = 1;select * from emp e2 where e2.salary &lt;(select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id);-- 11. 查询所有部门信息并统计部门的员工人数 select count(e.dept_id), d.name from emp e right join dept don e.dept_id = d.idgroup by d.id;-- 子查询-- 第一步，计算每个部门的人数 select count(*) from emp e where e.dept_id = 1;-- 第二步，得出结果 select d.id, d.name, (select count(*) from emp ewhere e.dept_id = d.id) &#x27;人数&#x27; from dept d;-- 12. 查询所有学生的选课情况，展示出学生名称，学号，课程名称 select s.name &#x27;姓名&#x27;, s.no &#x27;学号&#x27;, c.name &#x27;课程名称&#x27; fromstudent s, course c , student_course scwhere s.id = sc.studentidand sc. courseid = c.id;select * from student_course;select * from student;select * from course; 多表查询-总结1. 多表关系多表之间的关系分为三类： 一对多：在多的一方设置外键，关联一的一方的主键 多对多：建立中间表，中间表包含两个外键，关联两张表的主键 一对一：用于表结构拆分，在其中任何一方设置外键（UNIQUE)，关联另一方的主键 （一对一注：xx_order与xx_order_det就是这样的关系） 2. 多表查询内连接 隐式： 1select * from 表A, 表B where 条件....; 显式： 1select * from 表A inner join 表B on 条件.....; 外连接 左外： 1select ... from 表A left join 表B on 条件...; 右外： 1select ... from 表A right join 表B on 条件...; 自连接： 1select * from 表A 别名1, 表B 别名2 where 条件...; 子查询：标量子查询，列子查询，行子查询，表子查询。事务事务简介事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。注意：默认MySQL的事务是自动提交的，即当执行一条DML语句，MySQL会隐式的提交事务。事务操作案例： 12345678910111213141516171819202122232425-- 事务操作 -- 数据准备 create table account ( id int primary key auto_increment comment &#x27;主键ID&#x27;, name varchar(10) comment &#x27;姓名&#x27;, money int comment &#x27;余额&#x27;) comment &#x27;账户表&#x27;;insert into accountvalues (null, &#x27;张三&#x27;, 2000), (null, &#x27;李四&#x27;, 2000);-- 恢复数据 update account set money = 2000;-- 转账操作 -- 1. 查询张三的余额 select * from account where name = &#x27;张三&#x27;;-- 2. 将张三的账户余额减去1000 update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;select * from account; 事务操作方式一：查看&#x2F;设置事务的提交方式 12select @@autocommit;set @@autocommit = 0; -- 将提交方式改为手动 提交事务 1commit; 回滚事务 1rollback; 案例： 12345678910111213141516171819set @@autocommit = 0;select @@autocommit;-- 恢复数据 update account set money = 2000;-- 转账操作 -- 1. 查询张三的余额 select * from account where name = &#x27;张三&#x27;;-- 2. 将张三的账户余额减去1000 update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;commit;rollback;select * from account; 事务操作方式二：开启事务 1start transaction 或者 begin 提交事务 1commit 回滚事务 1rollback 案例： 123456789101112131415161718-- 方式2select @@autocommit;set @@autocommit = 1;begin; -- 事务开始 -- 1. 查询张三的余额 select * from account where name = &#x27;张三&#x27;;-- 2. 将张三的账户余额减去1000 update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;commit; -- 提交事务rollback; -- 回滚事务 commit 之前： commit 之后： 出错了就rollback事务四大特性（ACID）原子性 A - atomicity 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。一致性 C - consistency 事务完成时，必须使所有数据都保持一致隔离性 I - isolation 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境运行持久性 D - durability 事务一旦提交或回滚，它对数据库中数据的修改就是永久的并发事务问题 问题描述脏读一个事务读取到另一个事务未提交的数据不可重复读一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读幻读一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，发现这行数据已经存在了，好像出现了”幻影“。 事务隔离级别 隔离级别脏读不可重复读幻读Read uncommittedallowallowallowRead commiited (Oracle 默认）noallowallowRepeatable Read (MySQL 默认）nonoallowSerializablenonono 查看事务隔离级别： 1select @@transaction_isolation; 设置事务隔离级别： 12set [session|global] transaction isolation level&#123;read uncommitted | read committed | repeatable read | serializable&#125; 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- 设置事务隔离级别案例 -- 演示脏读 set session transaction isolation level read uncommitted;begin;select * from account; -- id = 1, money = 2000;-- 新开个session，执行# start transaction# update account set money = 2001 where id = 1;select * from account; -- 发现数据更新了 money = 2001commit;-- 演示不可重复读 -- 在一个事务里修改隔离级别是不会起作用的 set session transaction isolation level read committed;begin;select * from account; -- 发现数据是没有更新的 money = 2000;-- 新开的session里执行# commitselect * from account; -- 发现数据更新了 money = 2001;commit;-- 演示可重复读 set session transaction isolation level repeatable read;begin;select * from account; -- id = 1, money = 2001-- 新开的session里执行 # being# update account set money = 2005 where id = 1;# commit;select * from account; -- 发现数据没有更新 money = 2001commit;select * from account; -- 这时候在上一个事务之外，读到了 money = 2005-- 演示幻读 begin;select * from account; -- 这时候只读到两条数据 -- 在新session里执行 # begin;# insert into account values (3, &#x27;王五&#x27;, 2000);# commit;insert into account values (3, &#x27;王五&#x27;, 2000); -- 执行失败，原因是新session读已提交 select * from account; -- 依然读不到 id为3的数据，称之为幻读 commit;-- 演示串行化 delete from account where id = 3;set session transaction isolation level serializable;begin;select * from account; -- 这时候只读到两条数据 -- 在新开session里执行 # begin;# insert into account values (3, &#x27;王五&#x27;, 2000);# 发现新session卡住了，不能动弹 commit;# 发现新session里的insert执行完成了。 注意：事务隔离级别越高，数据越安全，但是效率也越低。总结：1. 事务简介事务是一组操作的集合，一荣俱荣，一损俱损2. 事务操作 12start transaction; 或者 begin; -- 开启事务commit/rollback; -- 提交/回滚 事务3. 事务四大特性原子性A、一致性C、隔离性I、持久性D4. 并发事务问题脏读、不可重复读、幻读5. 事务隔离级别read uncommitted, read committed, repeatable read, serializable基础篇总结MySQL概述 - SQL -函数 - 约束 - 多表查询 - 事务 转载自本人公众号笔记：MySQL数据库 - 基础篇，归类为原创。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xqtony.github.io/tags/MySQL/"},{"name":"原创","slug":"原创","permalink":"https://xqtony.github.io/tags/%E5%8E%9F%E5%88%9B/"}]}]